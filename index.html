<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="记录学习与成长">
<meta property="og:type" content="website">
<meta property="og:title" content="DarkYellowCat&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="DarkYellowCat&#39;s Blog">
<meta property="og:description" content="记录学习与成长">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="DarkYellowCat">
<meta property="article:tag" content="计科, Java, Maven, Spring, MyBatis, Linux, 后端">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>DarkYellowCat's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">DarkYellowCat's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">分享技术与思考</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/darkyellowcat" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/01/25/%E6%9B%B4%E6%96%B0%E8%AE%A1%E5%88%92-todoList/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DarkYellowCat">
      <meta itemprop="description" content="记录学习与成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarkYellowCat's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/01/25/%E6%9B%B4%E6%96%B0%E8%AE%A1%E5%88%92-todoList/" class="post-title-link" itemprop="url">记录更新</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2026-01-25 01:59:12" itemprop="dateCreated datePublished" datetime="2026-01-25T01:59:12+00:00">2026-01-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1><span id="更新规划">更新规划</span></h1><h3><span id="docker学习笔记">docker学习笔记</span></h3><h3><span id="计算机网络">计算机网络</span></h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/01/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DarkYellowCat">
      <meta itemprop="description" content="记录学习与成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarkYellowCat's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/01/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/" class="post-title-link" itemprop="url">'二叉树的最大深度'</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2026-01-22 14:27:22" itemprop="dateCreated datePublished" datetime="2026-01-22T14:27:22+00:00">2026-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-01-25 01:59:12" itemprop="dateModified" datetime="2026-01-25T01:59:12+00:00">2026-01-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>构造</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode left, right;</span><br><span class="line">    TreeNode() &#123;&#125;;</span><br><span class="line">    TreeNode(int val)&#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">        this.left = left;</span><br><span class="line">        this.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="1自顶向下">1.自顶向下</span></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        if (root == null) return 0;</span><br><span class="line">        else if (root.left == null &amp;&amp; root.right == null) return 1;</span><br><span class="line">        else &#123;</span><br><span class="line">            int leftDepth = maxDepth(root.left);</span><br><span class="line">            int rightDepth = maxDepth(root.right);</span><br><span class="line">            return Math.max(leftDepth, rightDepth) + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<h1><span id="2自底向上">2.自底向上</span></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">    int ans = 0;</span><br><span class="line"></span><br><span class="line">    private void dfs(TreeNode root, int depth)&#123;</span><br><span class="line">        if (root == null) return;</span><br><span class="line">        depth++;</span><br><span class="line">        if (root.left == null &amp;&amp; root.right == null)&#123;</span><br><span class="line">            ans = Math.max(ans, depth);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left, depth);</span><br><span class="line">        dfs(root.right, depth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        dfs(root, 0);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2026/01/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DarkYellowCat">
      <meta itemprop="description" content="记录学习与成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarkYellowCat's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/01/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/" class="post-title-link" itemprop="url">'二叉树的遍历'</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2026-01-22 10:41:31" itemprop="dateCreated datePublished" datetime="2026-01-22T10:41:31+00:00">2026-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-01-25 01:59:12" itemprop="dateModified" datetime="2026-01-25T01:59:12+00:00">2026-01-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>以中序遍历进行介绍</p>
<p>构造</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode left, right;</span><br><span class="line">    TreeNode() &#123;&#125;;</span><br><span class="line">    TreeNode(int val)&#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">        this.left = left;</span><br><span class="line">        this.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="1递归">1.递归</span></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Recursion &#123;</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        inorder(root, ans);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    private void preorder(TreeNode node, List&lt;Integer&gt; res)&#123;</span><br><span class="line">        if (node == null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(node.left, res);</span><br><span class="line">        res.add(node.val);</span><br><span class="line">        inorder(node.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<h1><span id="2迭代">2.迭代</span></h1><p>用栈来实现二叉树的遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Iteration &#123;</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        TreeNode curr = root;</span><br><span class="line"></span><br><span class="line">        while (curr != null || !stack.isEmpty()) &#123;</span><br><span class="line">            // 一路向左</span><br><span class="line">            while (curr != null) &#123;</span><br><span class="line">                stack.push(curr);</span><br><span class="line">                curr = curr.left;</span><br><span class="line">            &#125;</span><br><span class="line">            // 弹出栈顶（最左节点）</span><br><span class="line">            curr = stack.pop();</span><br><span class="line">            ans.add(curr.val);      // 访问</span><br><span class="line">            curr = curr.right;      // 转向右子树</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<h1><span id="3mirris">3.Mirris</span></h1><p>对于当前节点 curr：</p>
<ul>
<li>如果 没有左子树：直接访问 curr，然后进入右子树。</li>
<li>如果 有左子树：<br>找到 curr 的前驱节点（即左子树中的最右节点，记为 pre）。</li>
<li><ul>
<li>如果 pre.right &#x3D;&#x3D; null：说明第一次访问，建立线索 pre.right &#x3D; curr，然后进入左子树。</li>
</ul>
</li>
<li><ul>
<li>如果 pre.right &#x3D;&#x3D; curr：说明左子树已遍历完，断开线索（恢复原树结构），访问 curr，然后进入右子树。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Mirris &#123;</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        TreeNode curr = root;</span><br><span class="line">        while (curr != null) &#123;</span><br><span class="line">            if (curr.left == null) &#123;</span><br><span class="line">                ans.add(curr.val);</span><br><span class="line">                curr = curr.right;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 找到左子树的最右节点（前驱）</span><br><span class="line">                TreeNode pre = curr.left;</span><br><span class="line">                while (pre.right != null &amp;&amp; pre.right != curr) &#123;</span><br><span class="line">                    pre = pre.right;</span><br><span class="line">                &#125;</span><br><span class="line">                if (pre.right == null) &#123;</span><br><span class="line">                    // 建立线索</span><br><span class="line">                    pre.right = curr;</span><br><span class="line">                    curr = curr.left;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 线索已存在，说明左子树已遍历完</span><br><span class="line">                    pre.right = null; // 恢复树结构</span><br><span class="line">                    ans.add(curr.val);</span><br><span class="line">                    curr = curr.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<h1><span id="4测试">4.测试</span></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TreeNode root = new TreeNode(1);</span><br><span class="line">        root.right = new TreeNode(2);</span><br><span class="line">        root.right.left = new TreeNode(3);</span><br><span class="line"></span><br><span class="line">        Recursion recursion = new Recursion();</span><br><span class="line">        List&lt;Integer&gt; res1 = recursion.inorderTraversal(root);</span><br><span class="line">        System.out.println(&quot;Recursion: &quot; + res1);</span><br><span class="line"></span><br><span class="line">        Iteration iteration = new Iteration();</span><br><span class="line">        List&lt;Integer&gt; res2 = iteration.inorderTraversal(root);</span><br><span class="line">        System.out.println(&quot;Iteration: &quot; + res2);</span><br><span class="line"></span><br><span class="line">        Mirris mirris = new Mirris();</span><br><span class="line">        List&lt;Integer&gt; res3 = mirris.inorderTraversal(root);</span><br><span class="line">        System.out.println(&quot;Mirris: &quot; + res3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给出的树结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>中序遍历（左 → 根 → 右）：[1, 3, 2]</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/17/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DarkYellowCat">
      <meta itemprop="description" content="记录学习与成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarkYellowCat's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/12/17/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">'单调队列'</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-12-17 15:27:24" itemprop="dateCreated datePublished" datetime="2025-12-17T15:27:24+00:00">2025-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-01-25 01:59:12" itemprop="dateModified" datetime="2026-01-25T01:59:12+00:00">2026-01-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1><span id="简介">简介</span></h1><p><a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/monotonous-queue/">oi-wiki</a> 中对单调队列的解释是：「单调」指的是队列中元素具有某种单调性（递增或递减），而「队列」指元素只能在队头和队尾进行操作。</p>
<p>单调队列并不是一种新的数据结构，而是一种<strong>维护队列内部元素有序性的思想</strong>。它通常配合滑动窗口问题使用，用于在均摊 O(1) 的时间复杂度内维护区间最值。</p>
<p>常见形式包括：</p>
<ul>
<li>单调递增队列：队头元素最小</li>
<li>单调递减队列：队头元素最大</li>
</ul>
<h1><span id="java实现">Java实现</span></h1><p>以下以「维护区间最大值的单调递减队列」为例进行说明。</p>
<p>实现要点：</p>
<ol>
<li>队列中存储的是<strong>数组下标</strong>而不是元素值，便于判断是否滑出窗口</li>
<li>新元素入队时，从队尾删除所有比它小的元素，维持单调性</li>
<li>队头若已经不在当前窗口范围内，需要及时弹出</li>
</ol>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonotonicQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队：维护单调递减</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt;= nums[index]) &#123;</span><br><span class="line">            deque.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        deque.offerLast(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队：移除滑出窗口的元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">(<span class="type">int</span> indexLimit)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!deque.isEmpty() &amp;&amp; deque.peekFirst() &lt; indexLimit) &#123;</span><br><span class="line">            deque.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前窗口最大值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[deque.peekFirst()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="例题">例题</span></h1><p>给出一个长度为 n 的数组，编程输出每 k 个连续的数中的最大值和最小值。</p>
<p>该问题是单调队列的经典应用，也被称为「滑动窗口最值问题」。</p>
<p>思路说明：</p>
<ul>
<li>使用一个单调递减队列维护最大值</li>
<li>使用一个单调递增队列维护最小值</li>
<li>窗口每向右移动一步，只需对新元素入队、对过期元素出队即可</li>
</ul>
<p>示例实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlidingWindowMinMax</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; maxQ = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; minQ = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 维护最大值队列（递减）</span></span><br><span class="line">            <span class="keyword">while</span> (!maxQ.isEmpty() &amp;&amp; nums[maxQ.peekLast()] &lt;= nums[i]) &#123;</span><br><span class="line">                maxQ.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            maxQ.offerLast(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 维护最小值队列（递增）</span></span><br><span class="line">            <span class="keyword">while</span> (!minQ.isEmpty() &amp;&amp; nums[minQ.peekLast()] &gt;= nums[i]) &#123;</span><br><span class="line">                minQ.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            minQ.offerLast(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移除滑出窗口的元素</span></span><br><span class="line">            <span class="keyword">if</span> (maxQ.peekFirst() &lt;= i - k) maxQ.pollFirst();</span><br><span class="line">            <span class="keyword">if</span> (minQ.peekFirst() &lt;= i - k) minQ.pollFirst();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从第一个完整窗口开始输出结果</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(</span><br><span class="line">                    <span class="string">&quot;max=&quot;</span> + nums[maxQ.peekFirst()] + <span class="string">&quot;, min=&quot;</span> + nums[minQ.peekFirst()]</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度分析：</p>
<ul>
<li>每个元素最多入队、出队一次</li>
<li>总时间复杂度为 O(n)</li>
<li>空间复杂度为 O(k)</li>
</ul>
<p>该题展示了单调队列在处理区间最值问题时，相比朴素枚举 O(nk) 解法的巨大优势。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/16/Java8%E7%89%B9%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DarkYellowCat">
      <meta itemprop="description" content="记录学习与成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarkYellowCat's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/12/16/Java8%E7%89%B9%E6%80%A7/" class="post-title-link" itemprop="url">'Java8特性'</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-12-16 13:47:43" itemprop="dateCreated datePublished" datetime="2025-12-16T13:47:43+00:00">2025-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-01-25 01:59:12" itemprop="dateModified" datetime="2026-01-25T01:59:12+00:00">2026-01-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>本文总结 Java 8 中最常用、最核心的三项特性：Lambda 表达式、Stream API 与 Optional。内容以“已学过、快速回顾与查阅”为目标，侧重概念理解与典型用法。</p>
</blockquote>
<hr>
<h2><span id="目录导航">目录导航</span></h2><ul>
<li><a href="#1lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F">1. Lambda 表达式</a></li>
<li><a href="#2stream-api">2. Stream API</a></li>
<li><a href="#3optional">3. Optional</a></li>
</ul>
<hr>
<h1><span id="1lambda表达式">1.Lambda表达式</span></h1><h2><span id="1简介">1.简介</span></h2><p>Lambda 表达式是 Java 8 引入的一种匿名函数语法，用于简化只有一个抽象方法的接口（函数式接口）的实现方式。它本质上是一段可以被传递和执行的代码，使 Java 在一定程度上具备了函数式编程的特征。</p>
<p>在 Java 8 之前，若要实现接口通常需要使用匿名内部类，代码冗长且可读性较差。Lambda 表达式通过更简洁的语法，使“做什么”比“怎么写”更加直观。</p>
<h2><span id="2作用">2.作用</span></h2><p>Lambda 表达式的主要作用包括：</p>
<ol>
<li><p>简化代码结构<br>使用 Lambda 可以显著减少匿名内部类的样板代码，使核心逻辑更加突出。</p>
</li>
<li><p>提高可读性<br>在集合操作、事件回调等场景中，Lambda 能让代码更加贴近自然语言描述。</p>
</li>
<li><p>支持函数式编程风格<br>Lambda 是 Stream API、Optional 等特性的基础，使 Java 能以声明式方式处理数据。</p>
</li>
</ol>
<h2><span id="3使用">3.使用</span></h2><p>Stream 的典型使用流程为：</p>
<ol>
<li>获取 Stream</li>
<li>中间操作（可选，可多次）</li>
<li>终止操作</li>
</ol>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> list.stream()</span><br><span class="line">        .filter(x -&gt; x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        .map(x -&gt; x * x)</span><br><span class="line">        .reduce(<span class="number">0</span>, Integer::sum);</span><br></pre></td></tr></table></figure>

<p>常见中间操作：</p>
<ul>
<li>filter</li>
<li>map</li>
<li>sorted</li>
<li>distinct</li>
</ul>
<p>常见终止操作：</p>
<ul>
<li>forEach</li>
<li>collect</li>
<li>reduce</li>
<li>count</li>
</ul>
<p>需要注意：</p>
<ul>
<li>Stream 只能被消费一次</li>
<li>Stream 操作是惰性执行的，只有遇到终止操作才会真正执行</li>
</ul>
<h2><span id="4示例">4.示例</span></h2><p>将传统集合遍历方式改写为 Stream 写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Jerry&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name.length() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        result.add(name.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Stream 改写后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; result = names.stream()</span><br><span class="line">        .filter(name -&gt; name.length() &gt; <span class="number">3</span>)</span><br><span class="line">        .map(String::toUpperCase)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>Stream 写法将“过滤—转换—收集”的数据处理流程清晰地表达出来，避免了显式的循环和临时变量。</p>
<p><a href="#%E7%9B%AE%E5%BD%95%E5%AF%BC%E8%88%AA">返回顶部</a></p>
<hr>
<h1><span id="2stream-api">2.Stream API</span></h1><h2><span id="1简介">1.简介</span></h2><p>Stream API 是 Java 8 提供的一套用于操作集合数据的全新抽象。Stream 并不是数据结构，而是一种对数据源（如集合、数组）的高层次操作视图。</p>
<p>Stream 强调“做什么”，而非“如何遍历”，通过链式调用的方式完成对数据的处理。</p>
<h2><span id="2作用">2.作用</span></h2><p>Stream API 的主要作用包括：</p>
<ol>
<li><p>简化集合操作<br>过滤、映射、排序、聚合等操作可以用一行链式代码完成。</p>
</li>
<li><p>提高代码表达力<br>使用 Stream 可以清晰表达数据处理流程，减少中间变量。</p>
</li>
<li><p>支持并行处理<br>通过 parallelStream()，可以较低成本地利用多核 CPU 提升性能。</p>
</li>
</ol>
<h2><span id="3使用">3.使用</span></h2><p>Stream 的典型使用流程为：</p>
<ol>
<li>获取 Stream</li>
<li>中间操作（可选，可多次）</li>
<li>终止操作</li>
</ol>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);</span><br><span class="line"></span><br><span class="line">int sum = list.stream()</span><br><span class="line">        .filter(x -&gt; x % 2 == 0)</span><br><span class="line">        .map(x -&gt; x * x)</span><br><span class="line">        .reduce(0, Integer::sum);</span><br></pre></td></tr></table></figure>

<p>常见中间操作：</p>
<ul>
<li>filter</li>
<li>map</li>
<li>sorted</li>
<li>distinct</li>
</ul>
<p>常见终止操作：</p>
<ul>
<li>forEach</li>
<li>collect</li>
<li>reduce</li>
<li>count</li>
</ul>
<p>需要注意：</p>
<ul>
<li>Stream 只能被消费一次</li>
<li>Stream 操作是惰性执行的，只有遇到终止操作才会真正执行</li>
</ul>
<p><a href="#%E7%9B%AE%E5%BD%95%E5%AF%BC%E8%88%AA">返回顶部</a></p>
<hr>
<h1><span id="3optional">3.Optional</span></h1><h2><span id="1简介">1.简介</span></h2><p>Optional 是 Java 8 引入的一个容器类，用于显式表示“可能为空”的值。它的出现旨在减少空指针异常（NullPointerException），并引导开发者以更加安全的方式处理空值。</p>
<p>Optional 本身并不是为了解决所有 null 问题，而是作为一种 API 设计层面的约束和提示。</p>
<h2><span id="2作用">2.作用</span></h2><p>Optional 的主要作用包括：</p>
<ol>
<li><p>减少空指针异常<br>通过强制检查或处理空值，降低运行时错误风险。</p>
</li>
<li><p>提高代码可读性<br>方法返回 Optional，可以明确告诉调用者：返回值可能不存在。</p>
</li>
<li><p>鼓励函数式写法<br>Optional 与 Lambda 配合使用，可避免大量的 if-null 判断。</p>
</li>
</ol>
<h2><span id="3使用">3.使用</span></h2><p>创建 Optional 的常见方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; op1 = Optional.of(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">Optional&lt;String&gt; op2 = Optional.ofNullable(<span class="literal">null</span>);</span><br><span class="line">Optional&lt;String&gt; op3 = Optional.empty();</span><br></pre></td></tr></table></figure>

<p>常用方法示例：</p>
<ol>
<li>判断是否有值</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op1.isPresent();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>获取值（不推荐直接使用）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op1.get();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>提供默认值</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> op2.orElse(<span class="string">&quot;default&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用 Lambda 处理</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op1.ifPresent(v -&gt; System.out.println(v));</span><br></pre></td></tr></table></figure>

<h2><span id="4示例">4.示例</span></h2><p>将传统的空值判断代码改写为 Optional 写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> getValue();</span><br><span class="line"><span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">    System.out.println(value.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Optional 改写后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional.ofNullable(getValue())</span><br><span class="line">        .map(String::length)</span><br><span class="line">        .ifPresent(System.out::println);</span><br></pre></td></tr></table></figure>

<p>Optional 通过链式调用，将空值判断与业务逻辑合并，使代码更加紧凑且不易出错。</p>
<p><a href="#%E7%9B%AE%E5%BD%95%E5%AF%BC%E8%88%AA">返回顶部</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/05/%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DarkYellowCat">
      <meta itemprop="description" content="记录学习与成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarkYellowCat's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/12/05/%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">链表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-12-05 15:46:21" itemprop="dateCreated datePublished" datetime="2025-12-05T15:46:21+00:00">2025-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-01-25 01:59:12" itemprop="dateModified" datetime="2026-01-25T01:59:12+00:00">2026-01-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1><span id="总目录">总目录</span></h1><ol>
<li><a href="#middle-node">链表的中间节点</a></li>
<li><a href="#reverse-list">反转链表</a></li>
<li><a href="#palindrome-linked-list">回文链表</a></li>
<li><a href="#reorder-list">重排链表</a></li>
<li><a href="#remove-linked-list-elements">移除链表元素</a></li>
<li><a href="#swap-nodes-in-pairs">两两交换链表中的节点</a></li>
<li><a href="#merge-two-sorted-lists">合并两个有序链表</a></li>
</ol>
<p><a id="middle-node"></a></p>
<h1><span id="链表的中间节点-快慢指针">链表的中间节点-快慢指针</span></h1><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/middle-of-the-linked-list/">题号：876</a><br>给你单链表的头结点 head ，请你找出并返回链表的中间结点。</p>
<p>如果有两个中间结点，则返回第二个中间结点。</p>
<p>输入：head &#x3D; [1,2,3,4,5]</p>
<p>输出：[3,4,5]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode middleNode(ListNode head) &#123;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        ListNode q = head;</span><br><span class="line">        while(q != null &amp;&amp; q.next != null)&#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">            q = q.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当快指针遍历完时，慢指针刚好在整个链表中间。</li>
</ul>
<p><a id="reverse-list"></a></p>
<h1><span id="反转链表">反转链表</span></h1><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/submissions/682934307/">题号：206</a></p>
<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
<p>输入：head &#x3D; [1,2,3,4,5]</p>
<p>输出：[5,4,3,2,1]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        ListNode pre = null;</span><br><span class="line">        ListNode q = head;</span><br><span class="line">        while(q != null)&#123;</span><br><span class="line">            ListNode nxt = q.next;</span><br><span class="line">            q.next = pre;</span><br><span class="line">            pre = q;</span><br><span class="line">            q = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a id="palindrome-linked-list"></a></p>
<h1><span id="回文链表">回文链表</span></h1><p>-前置 ：<a href="#middle-node">链表的中间节点</a>、<a href="#reverse-list">反转链表</a><br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-linked-list/">题号：234</a></p>
<p>给你一个单链表的头节点 <code>head</code>，请判断该链表是否为回文链表。</p>
<ol>
<li>用<strong>快慢指针</strong>找到链表中点（偶数长度时取<strong>后半段起点</strong>，即第二个中间节点）；</li>
<li><strong>反转后半段链表</strong>；</li>
<li>用两个指针分别从<strong>头节点</strong>和<strong>反转后的后半段头节点</strong>同步遍历比较；</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isPalindrome(ListNode head) &#123;</span><br><span class="line">        // 快慢指针</span><br><span class="line">        ListNode fast =head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        while (fast != null &amp;&amp; fast.next != null)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        // 反转</span><br><span class="line">        ListNode pre = null;</span><br><span class="line">        ListNode cur = slow;</span><br><span class="line">        while (cur != null) &#123;</span><br><span class="line">            ListNode nxt = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nxt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (pre != null)&#123;</span><br><span class="line">            if(pre.val != head.val)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="类似例题">类似例题</span></h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-number/description/">题号：9 回文数</a></p>
<p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isPalindrome(int x) &#123;</span><br><span class="line">        if(x &lt; 0 || x &gt; 0 &amp;&amp; x % 10 == 0)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int rev = 0;</span><br><span class="line">        while(rev &lt; x / 10)&#123;</span><br><span class="line">            rev = rev * 10 + x % 10;</span><br><span class="line">            x /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return rev == x || rev == x / 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a id="reorder-list"></a></p>
<h1><span id="重排链表">重排链表</span></h1><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reorder-list/description/">题号：143</a></p>
<p>给定一个单链表 L 的头节点 head ，单链表 L 表示为：</p>
<p>L0 → L1 → … → Ln - 1 → Ln<br>请将其重新排列后变为：</p>
<p>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …<br>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void reorderList(ListNode head) &#123;</span><br><span class="line">        ListNode mid = middle(head);</span><br><span class="line">        ListNode head2 = reverse(mid);</span><br><span class="line">        while(head2.next != null)&#123;</span><br><span class="line">            ListNode nxt = head.next;</span><br><span class="line">            ListNode nxt2 = head2.next;</span><br><span class="line">            head.next = head2;</span><br><span class="line">            head2.next = nxt;</span><br><span class="line">            head = nxt;</span><br><span class="line">            head2 = nxt2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ListNode reverse(ListNode head)&#123;</span><br><span class="line">        ListNode pre = null, cur = head;</span><br><span class="line">        while(cur != null)&#123;</span><br><span class="line">            ListNode nxt = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ListNode middle(ListNode head)&#123;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        while(fast != null &amp;&amp; fast.next != null)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a id="remove-linked-list-elements"></a></p>
<h1><span id="移除链表元素">移除链表元素</span></h1><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/description/">题号：203</a></p>
<p>输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6</p>
<p>输出：[1,2,3,4,5]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode removeElements(ListNode head, int val) &#123;</span><br><span class="line">        ListNode dummy = new ListNode();</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        while(cur.next != null )&#123;</span><br><span class="line">            if(cur.next.val == val)&#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="两两交换链表中的节点">两两交换链表中的节点</span></h1><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/">题号：24</a></p>
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p>输入：head &#x3D; [1,2,3,4]</p>
<p>输出：[2,1,4,3]</p>
<ul>
<li>方法一：迭代</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode swapPairs(ListNode head) &#123;</span><br><span class="line">        ListNode dummy = new ListNode(0, head);</span><br><span class="line">        ListNode node0 = dummy;</span><br><span class="line">        ListNode node1 = head;</span><br><span class="line">        while (node1 != null &amp;&amp; node1.next != null) &#123;</span><br><span class="line">            ListNode node2 = node1.next;</span><br><span class="line">            ListNode node3 = node2.next;</span><br><span class="line"></span><br><span class="line">            node0.next = node2; // 0 -&gt; 2</span><br><span class="line">            node2.next = node1; // 2 -&gt; 1</span><br><span class="line">            node1.next = node3; // 1 -&gt; 3</span><br><span class="line"></span><br><span class="line">            node0 = node1;</span><br><span class="line">            node1 = node3;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：递归</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode swapPairs(ListNode head) &#123;</span><br><span class="line">        if (head == null || head.next == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode node1 = head;</span><br><span class="line">        ListNode node2 = head.next;</span><br><span class="line">        ListNode node3 = node2.next;</span><br><span class="line"></span><br><span class="line">        node1.next = swapPairs(node3);</span><br><span class="line">        node2.next = node1;</span><br><span class="line"></span><br><span class="line">        return node2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="合并两个有序链表">合并两个有序链表</span></h1><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/description/?envType=study-plan-v2&envId=top-100-liked">题号：21</a></p>
<p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<p>输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]</p>
<p>输出：[1,1,2,3,4,4]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123;</span><br><span class="line">        ListNode dummy = new ListNode();</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        while(list1 != null &amp;&amp; list2 != null)&#123;</span><br><span class="line">            if(list1.val &lt; list2.val)&#123;</span><br><span class="line">                cur.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cur.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = list1 != null ? list1 : list2;</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/05/mysql%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DarkYellowCat">
      <meta itemprop="description" content="记录学习与成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarkYellowCat's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/12/05/mysql%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">'mysql学习'</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-12-05 00:09:56" itemprop="dateCreated datePublished" datetime="2025-12-05T00:09:56+00:00">2025-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-01-25 01:59:12" itemprop="dateModified" datetime="2026-01-25T01:59:12+00:00">2026-01-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1><span id="数据库操作">数据库操作</span></h1><h2><span id="创建">创建</span></h2><p>名称若为关键词需用单引号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE [IF NOT_EXISTS] XX</span><br></pre></td></tr></table></figure>
<h2><span id="查看x2f删除">查看&#x2F;删除</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES 查看数据库</span><br><span class="line">SHOW CREATE DATABASE XXX 数据库创建语句</span><br><span class="line">DROP DATABASE [IF EXITS] XX 删除数据库</span><br></pre></td></tr></table></figure>
<h2><span id="备份恢复">备份恢复</span></h2><p>必须在DOS执行<br>备份</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u * -p * -B 数据库</span><br></pre></td></tr></table></figure>
<p>生成 xx.sql文件<br>恢复</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Source xx.sq了、</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1><span id="表操作">表操作</span></h1><h2><span id="创建表">创建表</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name</span><br><span class="line">&#123;</span><br><span class="line">    field datatype</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>character 字符集 (不指定默认用数据库字符集)<br>collate 校队规则<br>ENGINE </p>
<h2><span id="修改表">修改表</span></h2><p>ALTER TABLE table_name</p>
<ul>
<li>ADD 添加列</li>
<li>MODIFY  修改列</li>
<li>DROP  删除列</li>
<li>Rename table name to new_name 修改表名</li>
<li>ALTER table name character set 字符集 修改字符集</li>
<li>NOT NULL DEFAULT 默认不为空</li>
<li>DESC 查看字段</li>
</ul>
<h1><span id="数据类型">数据类型</span></h1><h2><span id="数值类型">数值类型</span></h2><ol>
<li><p>整型 </p>
<pre><code> tinyint[1字节] (-127~127) unsigned(0~255)
 smallint[2]
 mediumint[3]
 int[4]
 bigint[8]
</code></pre>
</li>
<li><p>小数类型 </p>
<pre><code> float[4]
 double[8]
 decimal[M,D] (M为小数位数总数，D为小数点后的位数)(M默认10，D默认0)max(65,30)
</code></pre>
</li>
</ol>
<h2><span id="文本类型">文本类型</span></h2><ol>
<li>char(0~255)</li>
<li>varchar(0<del>65535[2^16-1]) 注：utf-8编码最大21844(65535 - 3)&#x2F;3  1</del>3个字节用于记录大小</li>
<li>text(0~2^16-1)</li>
<li>longtext(2^32-1)</li>
</ol>
<h3><span id="细节">细节</span></h3><ul>
<li>1.char(4)和varchar(4)中的4表示字符</li>
<li>2.char(4)是定长，varchar(4)是变长</li>
</ul>
<h2><span id="二进制数据">二进制数据</span></h2><ol>
<li>blob(0~2^16-1)</li>
<li>longblob(2^32-1)</li>
</ol>
<h2><span id="日期">日期</span></h2><ol>
<li>date [日期 年月日]</li>
<li>time [时间 时分秒]</li>
<li>datetime [YYYY-MM-DD HH:mm:ss]</li>
<li>timestamp 时间戳 自动更新：NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</li>
</ol>
<h1><span id="增删改查">增删改查</span></h1><h2><span id="insert">INSERT</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO table_name(columns)</span><br><span class="line">    VALUES (具体数值)</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>日期和字符数据需包含在单引号中</li>
<li>可以插入空值</li>
<li>insert into table () values (),(),()可以添加多条记录</li>
<li>给表中所有字段添加数据可以不写字段名称</li>
</ol>
<h2><span id="update">UPDATE</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE name</span><br><span class="line">    SET COLUNMS</span><br><span class="line">    (WHERE ...)</span><br></pre></td></tr></table></figure>
<h2><span id="detele">DETELE</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE name FROM</span><br><span class="line">    WHERE ...</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>delete不能单独删除一列的数据</li>
<li>delete只删除记录。不删除表本身</li>
</ol>
<h2><span id="select">SELECT</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT [DISTINCT] * | &#123;COLUMN&#125;</span><br><span class="line">  FROM table_name</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>DISTINCT 是否去重</li>
<li>使用表达式对查询的列进行运算：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT *|&#123;COLUMN1|EXPRESSION&#125;</span><br><span class="line">  FROM table_name</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>AS</code> 语句</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name as 别名 from table</span><br></pre></td></tr></table></figure>


<ol start="4">
<li><code>WHERE</code> 子句：条件筛选</li>
</ol>
<p>🔹 逻辑运算符（组合条件）</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>AND</code></td>
<td>逻辑与（全部为真才真）</td>
</tr>
<tr>
<td><code>OR</code></td>
<td>逻辑或（任一为真即真）</td>
</tr>
<tr>
<td><code>NOT</code></td>
<td>逻辑非（取反）</td>
</tr>
</tbody></table>
<blockquote>
<p>✅ 注意：<code>AND</code> 优先级高于 <code>OR</code>，建议用括号 <code>()</code> 明确逻辑分组，例如：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> (status <span class="operator">=</span> <span class="string">&#x27;active&#x27;</span> <span class="keyword">OR</span> level <span class="operator">&gt;</span> <span class="number">5</span>) <span class="keyword">AND</span> <span class="keyword">NOT</span> is_deleted</span><br></pre></td></tr></table></figure></blockquote>
<hr>
<p>🔹 比较运算符（判断单值&#x2F;集合）</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>运算符 &#x2F; 语法</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>常规比较</td>
<td><code>=</code>, <code>&lt;&gt;</code> 或 <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></td>
<td><code>age &gt; 18</code></td>
</tr>
<tr>
<td>区间匹配</td>
<td><code>BETWEEN val1 AND val2</code></td>
<td><code>score BETWEEN 60 AND 100</code>（含边界）</td>
</tr>
<tr>
<td>集合成员判断</td>
<td><code>IN (val1, val2, ...)</code></td>
<td><code>dept_id IN (1, 3, 5)</code></td>
</tr>
<tr>
<td>模糊匹配</td>
<td><code>LIKE</code> &#x2F; <code>NOT LIKE</code> + 通配符</td>
<td><code>name LIKE &#39;A%&#39;</code>（<code>%</code>：任意字符，<code>_</code>：单字符）</td>
</tr>
<tr>
<td>空值判断（⚠️特殊）</td>
<td><code>IS NULL</code> &#x2F; <code>IS NOT NULL</code></td>
<td><code>email IS NULL</code>（不能用 <code>= NULL</code>！）</td>
</tr>
</tbody></table>
<blockquote>
<p>📌 提示：</p>
<ul>
<li><code>NULL</code> 表示“缺失&#x2F;未知”，任何与 <code>NULL</code> 的比较（如 <code>=</code>, <code>!=</code>）结果均为 <code>UNKNOWN</code>。</li>
<li>字符串模糊匹配注意大小写敏感性（依赖数据库设置，如 MySQL 默认不区分，PostgreSQL 区分）。</li>
</ul>
</blockquote>
<ol start="5">
<li>ORDER BY 排序查询结果</li>
</ol>
<ul>
<li>升序 ASC</li>
<li>降序 DESC</li>
</ul>
<h2><span id="合计函数-count">合计函数 COUNT</span></h2><p>返回行的总数<br><code>SELECT COUNT *|COLUMN FROM table_name</code></p>
<h2><span id="合计函数-sum">合计函数 SUM</span></h2><p>返回满足WHERE条件的行的和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT SUM (COLUMN) FROM table_name</span><br></pre></td></tr></table></figure>

<h2><span id="合计函数-avg">合计函数 AVG</span></h2><p>返回平均值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT AVG (COLUMN) FROM table_name</span><br></pre></td></tr></table></figure>

<h2><span id="合计函数-maxx2fmin">合计函数 MAX&#x2F;MIN</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT MAX/MIN (COLUMN) FROM table_name</span><br></pre></td></tr></table></figure>

<h2><span id="group-by-分组查询-having-限制显示结果">GROUP BY 分组查询 + HAVING 限制显示结果</span></h2><h2><span id="字符串函数">字符串函数</span></h2><h3><span id="一-基础操作">🔤 一、基础操作</span></h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>LENGTH(str)</code></td>
<td>返回字符串的<strong>字节长度</strong>（注意：UTF8 中中文占 3 字节）</td>
<td><code>LENGTH(&#39;你好&#39;)</code> → <code>6</code></td>
</tr>
<tr>
<td><code>CHAR_LENGTH(str)</code> 或 <code>CHARACTER_LENGTH(str)</code></td>
<td>返回字符串的<strong>字符个数</strong></td>
<td><code>CHAR_LENGTH(&#39;你好&#39;)</code> → <code>2</code></td>
</tr>
<tr>
<td><code>UPPER(str)</code> &#x2F; <code>UCASE(str)</code></td>
<td>转大写</td>
<td><code>UPPER(&#39;Hello&#39;)</code> → <code>&#39;HELLO&#39;</code></td>
</tr>
<tr>
<td><code>LOWER(str)</code> &#x2F; <code>LCASE(str)</code></td>
<td>转小写</td>
<td><code>LOWER(&#39;Hello&#39;)</code> → <code>&#39;hello&#39;</code></td>
</tr>
<tr>
<td><code>TRIM([{BOTH|LEADING|TRAILING} [remstr] FROM] str)</code></td>
<td>去除首尾空格或指定字符</td>
<td><code>TRIM(&#39;  abc  &#39;)</code> → <code>&#39;abc&#39;</code><br><code>TRIM(BOTH &#39;x&#39; FROM &#39;xxabcxx&#39;)</code> → <code>&#39;abc&#39;</code></td>
</tr>
<tr>
<td><code>LTRIM(str)</code></td>
<td>去除左侧空格</td>
<td><code>LTRIM(&#39;  abc&#39;)</code> → <code>&#39;abc&#39;</code></td>
</tr>
<tr>
<td><code>RTRIM(str)</code></td>
<td>去除右侧空格</td>
<td><code>RTRIM(&#39;abc  &#39;)</code> → <code>&#39;abc&#39;</code></td>
</tr>
</tbody></table>
<hr>
<h3><span id="二-拼接与拆分">🔗 二、拼接与拆分</span></h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>CONCAT(str1, str2, …)</code></td>
<td>拼接字符串（任一参数为 <code>NULL</code>，结果为 <code>NULL</code>）</td>
<td><code>CONCAT(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</code> → <code>&#39;abc&#39;</code></td>
</tr>
<tr>
<td><code>CONCAT_WS(sep, str1, str2, …)</code></td>
<td>用分隔符拼接（自动跳过 <code>NULL</code>）</td>
<td><code>CONCAT_WS(&#39;,&#39;, &#39;a&#39;, NULL, &#39;c&#39;)</code> → <code>&#39;a,c&#39;</code></td>
</tr>
<tr>
<td><code>SUBSTRING(str, pos[, len])</code><br>或 <code>SUBSTR(str, pos[, len])</code></td>
<td>从第 <code>pos</code> 位（从 1 开始）截取 <code>len</code> 个字符；<code>pos</code> 可为负（从末尾算）</td>
<td><code>SUBSTR(&#39;MySQL&#39;, 2, 3)</code> → <code>&#39;ySQ&#39;</code><br><code>SUBSTR(&#39;MySQL&#39;, -3)</code> → <code>&#39;SQL&#39;</code></td>
</tr>
<tr>
<td><code>LEFT(str, n)</code></td>
<td>取左边 <code>n</code> 个字符</td>
<td><code>LEFT(&#39;MySQL&#39;, 3)</code> → <code>&#39;MyS&#39;</code></td>
</tr>
<tr>
<td><code>RIGHT(str, n)</code></td>
<td>取右边 <code>n</code> 个字符</td>
<td><code>RIGHT(&#39;MySQL&#39;, 2)</code> → <code>&#39;QL&#39;</code></td>
</tr>
</tbody></table>
<hr>
<h3><span id="三-查找与定位">🔍 三、查找与定位</span></h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>LOCATE(substr, str[, pos])</code></td>
<td>返回 <code>substr</code> 在 <code>str</code> 中首次出现的位置（从 1 开始），可指定起始位置</td>
<td><code>LOCATE(&#39;S&#39;, &#39;MySQL&#39;)</code> → <code>3</code><br><code>LOCATE(&#39;Q&#39;, &#39;MySQL&#39;, 4)</code> → <code>4</code></td>
</tr>
<tr>
<td><code>INSTR(str, substr)</code></td>
<td>同 <code>LOCATE(substr, str)</code>，但参数顺序相反（兼容 Oracle）</td>
<td><code>INSTR(&#39;MySQL&#39;, &#39;S&#39;)</code> → <code>3</code></td>
</tr>
<tr>
<td><code>POSITION(substr IN str)</code></td>
<td>同 <code>LOCATE</code>，标准 SQL 写法</td>
<td><code>POSITION(&#39;S&#39; IN &#39;MySQL&#39;)</code> → <code>3</code></td>
</tr>
</tbody></table>
<hr>
<h3><span id="️-四-替换与格式化">🛠️ 四、替换与格式化</span></h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>REPLACE(str, from_str, to_str)</code></td>
<td>将 <code>str</code> 中所有 <code>from_str</code> 替换为 <code>to_str</code></td>
<td><code>REPLACE(&#39;a-b-c&#39;, &#39;-&#39;, &#39;/&#39;)</code> → <code>&#39;a/b/c&#39;</code></td>
</tr>
<tr>
<td><code>INSERT(str, pos, len, newstr)</code></td>
<td>在 <code>str</code> 的 <code>pos</code> 处删除 <code>len</code> 个字符，插入 <code>newstr</code></td>
<td><code>INSERT(&#39;Quadratic&#39;, 3, 4, &#39;What&#39;)</code> → <code>&#39;QuWhattic&#39;</code></td>
</tr>
<tr>
<td><code>LPAD(str, len, pad)</code></td>
<td>左填充：用 <code>pad</code> 将 <code>str</code> 补至 <code>len</code> 长（超长则截断）</td>
<td><code>LPAD(&#39;abc&#39;, 5, &#39;0&#39;)</code> → <code>&#39;00abc&#39;</code></td>
</tr>
<tr>
<td><code>RPAD(str, len, pad)</code></td>
<td>右填充</td>
<td><code>RPAD(&#39;abc&#39;, 5, &#39;x&#39;)</code> → <code>&#39;abcxx&#39;</code></td>
</tr>
<tr>
<td><code>REPEAT(str, n)</code></td>
<td>将 <code>str</code> 重复 <code>n</code> 次</td>
<td><code>REPEAT(&#39;Ha&#39;, 3)</code> → <code>&#39;HaHaHa&#39;</code></td>
</tr>
</tbody></table>
<hr>
<h3><span id="五-高级处理mysql-80">五、高级处理（MySQL 8.0+）</span></h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>REGEXP_LIKE(str, pattern[, match_type])</code></td>
<td>正则匹配（返回 1&#x2F;0）</td>
<td><code>SELECT &#39;abc123&#39; REGEXP &#39;^[a-z]+[0-9]+$&#39;</code> → <code>1</code></td>
</tr>
<tr>
<td><code>REGEXP_SUBSTR(str, pattern[, pos[, occ[, match_type]]])</code></td>
<td>提取匹配的子串</td>
<td><code>REGEXP_SUBSTR(&#39;user@example.com&#39;, &#39;@(.+)&#39;, 1, 1, &#39;i&#39;, 1)</code> → <code>&#39;example.com&#39;</code></td>
</tr>
<tr>
<td><code>REGEXP_REPLACE(str, pattern, replace_str[, pos[, occ[, match_type]]])</code></td>
<td>正则替换</td>
<td><code>REGEXP_REPLACE(&#39;abc123def&#39;, &#39;[0-9]+&#39;, &#39;#&#39;)</code> → <code>&#39;abc#def&#39;</code></td>
</tr>
<tr>
<td><code>REGEXP_INSTR(str, pattern[, pos[, occ[, return_opt[, match_type]]]])</code></td>
<td>返回匹配位置（支持更灵活控制）</td>
<td><code>REGEXP_INSTR(&#39;abc123def&#39;, &#39;[0-9]+&#39;)</code> → <code>4</code></td>
</tr>
</tbody></table>
<h2><span id="数学函数">数学函数</span></h2><p>以下是 <strong>MySQL 中常用的数学类函数</strong>（Mathematical Functions），适用于 MySQL 5.7 &#x2F; 8.0+，按功能分类整理，附典型用法与注意事项。</p>
<hr>
<h3><span id="一-基本运算与取整">一、基本运算与取整</span></h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>示例</th>
<th>注意</th>
</tr>
</thead>
<tbody><tr>
<td><code>ABS(X)</code></td>
<td>绝对值</td>
<td><code>ABS(-5)</code> → <code>5</code></td>
<td>支持整数、浮点、<code>DECIMAL</code></td>
</tr>
<tr>
<td><code>SIGN(X)</code></td>
<td>符号函数：正→1，负→-1，零→0</td>
<td><code>SIGN(-3.2)</code> → <code>-1</code></td>
<td></td>
</tr>
<tr>
<td><code>MOD(N, M)</code> 或 <code>N % M</code> 或 <code>N MOD M</code></td>
<td>取模（余数）</td>
<td><code>MOD(10, 3)</code> → <code>1</code><br><code>-10 MOD 3</code> → <code>-1</code></td>
<td>负数取模结果符号与被除数一致</td>
</tr>
<tr>
<td><code>FLOOR(X)</code></td>
<td>向下取整（不大于 X 的最大整数）</td>
<td><code>FLOOR(3.9)</code> → <code>3</code><br><code>FLOOR(-3.2)</code> → <code>-4</code></td>
<td></td>
</tr>
<tr>
<td><code>CEIL(X)</code> &#x2F; <code>CEILING(X)</code></td>
<td>向上取整（不小于 X 的最小整数）</td>
<td><code>CEIL(3.1)</code> → <code>4</code><br><code>CEIL(-3.2)</code> → <code>-3</code></td>
<td></td>
</tr>
<tr>
<td><code>ROUND(X[, D])</code></td>
<td>四舍五入；<code>D</code> 为小数位数（默认 0）</td>
<td><code>ROUND(3.456, 2)</code> → <code>3.46</code><br><code>ROUND(123, -1)</code> → <code>120</code></td>
<td><code>D</code> 可为负（对整数位取整）</td>
</tr>
<tr>
<td><code>TRUNCATE(X, D)</code></td>
<td>截断（直接舍弃小数，<strong>不四舍五入</strong>）</td>
<td><code>TRUNCATE(3.999, 1)</code> → <code>3.9</code><br><code>TRUNCATE(123.456, -1)</code> → <code>120</code></td>
<td>常用于精度控制</td>
</tr>
</tbody></table>
<hr>
<h3><span id="二-幂-指数与对数">二、幂、指数与对数</span></h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>POW(X, Y)</code> &#x2F; <code>POWER(X, Y)</code></td>
<td>X 的 Y 次方</td>
<td><code>POW(2, 3)</code> → <code>8</code><br><code>POW(4, 0.5)</code> → <code>2</code>（开平方）</td>
</tr>
<tr>
<td><code>SQRT(X)</code></td>
<td>平方根（X ≥ 0）</td>
<td><code>SQRT(16)</code> → <code>4</code></td>
</tr>
<tr>
<td><code>EXP(X)</code></td>
<td>e 的 X 次方</td>
<td><code>EXP(1)</code> ≈ <code>2.718281828459045</code></td>
</tr>
<tr>
<td><code>LN(X)</code></td>
<td>自然对数（以 e 为底，X &gt; 0）</td>
<td><code>LN(EXP(2))</code> → <code>2</code></td>
</tr>
<tr>
<td><code>LOG(X)</code></td>
<td>自然对数（同 <code>LN(X)</code>）</td>
<td><code>LOG(2.71828)</code> ≈ <code>1</code></td>
</tr>
<tr>
<td><code>LOG(B, X)</code></td>
<td>以 B 为底的对数（X &gt; 0, B &gt; 0, B ≠ 1）</td>
<td><code>LOG(10, 1000)</code> → <code>3</code></td>
</tr>
<tr>
<td><code>LOG2(X)</code></td>
<td>以 2 为底的对数</td>
<td><code>LOG2(8)</code> → <code>3</code></td>
</tr>
<tr>
<td><code>LOG10(X)</code></td>
<td>以 10 为底的对数</td>
<td><code>LOG10(100)</code> → <code>2</code></td>
</tr>
</tbody></table>
<hr>
<h3><span id="三-三角函数角度单位弧度">三、三角函数（角度单位：<strong>弧度</strong>）</span></h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>SIN(X)</code>, <code>COS(X)</code>, <code>TAN(X)</code></td>
<td>正弦、余弦、正切</td>
<td><code>SIN(PI()/2)</code> → <code>1</code></td>
</tr>
<tr>
<td><code>ASIN(X)</code>, <code>ACOS(X)</code>, <code>ATAN(X)</code></td>
<td>反正弦、反余弦、反正切</td>
<td><code>ASIN(1)</code> → <code>1.570796...</code>（≈π&#x2F;2）</td>
</tr>
<tr>
<td><code>ATAN(Y, X)</code> 或 <code>ATAN2(Y, X)</code></td>
<td>四象限反正切（返回点 <code>(X, Y)</code> 的角度）</td>
<td><code>ATAN2(1, 1)</code> → <code>0.785398...</code>（≈π&#x2F;4）</td>
</tr>
<tr>
<td><code>COT(X)</code></td>
<td>余切（&#x3D; 1 &#x2F; TAN(X)）</td>
<td><code>COT(PI()/4)</code> → <code>1</code></td>
</tr>
<tr>
<td><code>DEGREES(X)</code></td>
<td>弧度 → 角度</td>
<td><code>DEGREES(PI())</code> → <code>180</code></td>
</tr>
<tr>
<td><code>RADIANS(X)</code></td>
<td>角度 → 弧度</td>
<td><code>RADIANS(180)</code> → <code>3.141592653589793</code></td>
</tr>
</tbody></table>
<blockquote>
<p>⚠️ 注意：三角函数入参为<strong>弧度</strong>，若需角度计算，先用 <code>RADIANS()</code> 转换。</p>
</blockquote>
<hr>
<h3><span id="四-随机数">四、随机数</span></h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>RAND()</code></td>
<td>返回 <strong>[0, 1)</strong> 之间随机浮点数</td>
<td><code>RAND()</code> → <code>0.732...</code></td>
</tr>
<tr>
<td><code>RAND(N)</code></td>
<td>用种子 <code>N</code> 初始化，之后每次调用 <code>RAND()</code> 生成<strong>可重现</strong>序列</td>
<td><code>SELECT RAND(1), RAND(), RAND();</code> → 每次执行结果一致</td>
</tr>
</tbody></table>
<blockquote>
<p>✅ 生成 [a, b] 区间随机整数：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FLOOR</span>(a <span class="operator">+</span> RAND() <span class="operator">*</span> (b <span class="operator">-</span> a <span class="operator">+</span> <span class="number">1</span>))</span><br><span class="line"><span class="comment">-- 例如生成 [1, 100]：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> RAND() <span class="operator">*</span> <span class="number">100</span>);</span><br></pre></td></tr></table></figure></blockquote>
<hr>
<h3><span id="五-进制与位运算部分">五、进制与位运算（部分）</span></h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>BIN(N)</code></td>
<td>十进制 → 二进制字符串</td>
<td><code>BIN(10)</code> → <code>&#39;1010&#39;</code></td>
</tr>
<tr>
<td><code>OCT(N)</code></td>
<td>十进制 → 八进制字符串</td>
<td><code>OCT(10)</code> → <code>&#39;12&#39;</code></td>
</tr>
<tr>
<td><code>HEX(N)</code> &#x2F; <code>HEX(str)</code></td>
<td>十进制 → 十六进制字符串；或字符串转 HEX</td>
<td><code>HEX(255)</code> → <code>&#39;FF&#39;</code><br><code>HEX(&#39;A&#39;)</code> → <code>&#39;41&#39;</code></td>
</tr>
<tr>
<td><code>CONV(N, from_base, to_base)</code></td>
<td>任意进制转换（2~36 进制）</td>
<td><code>CONV(&#39;FF&#39;, 16, 10)</code> → <code>&#39;255&#39;</code><br><code>CONV(&#39;1010&#39;, 2, 16)</code> → <code>&#39;A&#39;</code></td>
</tr>
</tbody></table>
<hr>
<h3><span id="实用示例">实用示例</span></h3><ol>
<li><p><strong>计算用户年龄（假设 <code>birth_date</code> 为 DATE 类型）</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  name,</span><br><span class="line">  <span class="built_in">FLOOR</span>(DATEDIFF(CURDATE(), birth_date) <span class="operator">/</span> <span class="number">365.25</span>) <span class="keyword">AS</span> age</span><br><span class="line"><span class="keyword">FROM</span> users;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>评分归一化到 [0, 100]</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  score,</span><br><span class="line">  ROUND(<span class="number">100</span> <span class="operator">*</span> (score <span class="operator">-</span> min_score) <span class="operator">/</span> (max_score <span class="operator">-</span> min_score), <span class="number">1</span>) <span class="keyword">AS</span> normalized_score</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> score,</span><br><span class="line">         (<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(score) <span class="keyword">FROM</span> exams) <span class="keyword">AS</span> min_score,</span><br><span class="line">         (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(score) <span class="keyword">FROM</span> exams) <span class="keyword">AS</span> max_score</span><br><span class="line">  <span class="keyword">FROM</span> exams</span><br><span class="line">) t;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>生成带随机延迟的模拟数据</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  NOW() <span class="operator">+</span> <span class="type">INTERVAL</span> <span class="built_in">FLOOR</span>(RAND() <span class="operator">*</span> <span class="number">3600</span>) <span class="keyword">SECOND</span> <span class="keyword">AS</span> random_time;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p>以下是 <strong>MySQL 中常用的日期与时间函数</strong>（Date and Time Functions），适用于 MySQL 5.7 &#x2F; 8.0+，按功能分类整理，附详细说明、典型示例与实用技巧。</p>
<hr>
<h3><span id="一-获取当前日期x2f时间">一、获取当前日期&#x2F;时间</span></h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>示例</th>
<th>返回类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>NOW()</code> &#x2F; <code>SYSDATE()</code></td>
<td>当前日期时间（<code>YYYY-MM-DD HH:MM:SS</code>）</td>
<td><code>NOW()</code> → <code>&#39;2025-12-07 15:30:45&#39;</code></td>
<td><code>DATETIME</code></td>
</tr>
<tr>
<td><code>CURDATE()</code> &#x2F; <code>CURRENT_DATE</code></td>
<td>当前日期</td>
<td><code>CURDATE()</code> → <code>&#39;2025-12-07&#39;</code></td>
<td><code>DATE</code></td>
</tr>
<tr>
<td><code>CURTIME()</code> &#x2F; <code>CURRENT_TIME</code></td>
<td>当前时间</td>
<td><code>CURTIME()</code> → <code>&#39;15:30:45&#39;</code></td>
<td><code>TIME</code></td>
</tr>
<tr>
<td><code>UTC_DATE()</code></td>
<td>UTC 日期</td>
<td><code>UTC_DATE()</code> → <code>&#39;2025-12-07&#39;</code></td>
<td><code>DATE</code></td>
</tr>
<tr>
<td><code>UTC_TIME()</code></td>
<td>UTC 时间</td>
<td><code>UTC_TIME()</code> → <code>&#39;07:30:45&#39;</code></td>
<td><code>TIME</code></td>
</tr>
<tr>
<td><code>UTC_TIMESTAMP()</code></td>
<td>UTC 日期时间</td>
<td><code>UTC_TIMESTAMP()</code> → <code>&#39;2025-12-07 07:30:45&#39;</code></td>
<td><code>DATETIME</code></td>
</tr>
</tbody></table>
<blockquote>
<p> <code>NOW()</code> 返回<strong>语句开始执行时</strong>的时间；<code>SYSDATE()</code> 返回<strong>函数执行时</strong>的时间（在 <code>SLEEP()</code> 或触发器中差异明显）。</p>
</blockquote>
<hr>
<h3><span id="二-日期时间构造与提取">二、日期时间构造与提取</span></h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>DATE(expr)</code></td>
<td>提取日期部分</td>
<td><code>DATE(&#39;2025-12-07 15:30:45&#39;)</code> → <code>&#39;2025-12-07&#39;</code></td>
</tr>
<tr>
<td><code>TIME(expr)</code></td>
<td>提取时间部分</td>
<td><code>TIME(&#39;2025-12-07 15:30:45&#39;)</code> → <code>&#39;15:30:45&#39;</code></td>
</tr>
<tr>
<td><code>YEAR(date)</code></td>
<td>年份（1000–9999）</td>
<td><code>YEAR(&#39;2025-12-07&#39;)</code> → <code>2025</code></td>
</tr>
<tr>
<td><code>MONTH(date)</code></td>
<td>月份（1–12）</td>
<td><code>MONTH(&#39;2025-12-07&#39;)</code> → <code>12</code></td>
</tr>
<tr>
<td><code>DAY(date)</code> &#x2F; <code>DAYOFMONTH(date)</code></td>
<td>日期（1–31）</td>
<td><code>DAY(&#39;2025-12-07&#39;)</code> → <code>7</code></td>
</tr>
<tr>
<td><code>HOUR(time)</code></td>
<td>小时（0–23）</td>
<td><code>HOUR(&#39;15:30:45&#39;)</code> → <code>15</code></td>
</tr>
<tr>
<td><code>MINUTE(time)</code></td>
<td>分钟（0–59）</td>
<td><code>MINUTE(&#39;15:30:45&#39;)</code> → <code>30</code></td>
</tr>
<tr>
<td><code>SECOND(time)</code></td>
<td>秒（0–59）</td>
<td><code>SECOND(&#39;15:30:45&#39;)</code> → <code>45</code></td>
</tr>
<tr>
<td><code>DAYOFWEEK(date)</code></td>
<td>星期几（<strong>1&#x3D;周日</strong>, 2&#x3D;周一,…,7&#x3D;周六）</td>
<td><code>DAYOFWEEK(&#39;2025-12-07&#39;)</code> → <code>1</code>（2025-12-07 是周日）</td>
</tr>
<tr>
<td><code>WEEKDAY(date)</code></td>
<td>星期几（<strong>0&#x3D;周一</strong>, 1&#x3D;周二,…,6&#x3D;周日）</td>
<td><code>WEEKDAY(&#39;2025-12-07&#39;)</code> → <code>6</code></td>
</tr>
<tr>
<td><code>DAYOFYEAR(date)</code></td>
<td>一年中的第几天（1–366）</td>
<td><code>DAYOFYEAR(&#39;2025-12-07&#39;)</code> → <code>341</code></td>
</tr>
<tr>
<td><code>WEEK(date[, mode])</code></td>
<td>一年中的第几周（<code>mode</code> 控制起始日与范围）</td>
<td><code>WEEK(&#39;2025-12-07&#39;)</code> → <code>49</code>（默认周日为每周首日）</td>
</tr>
<tr>
<td><code>YEARWEEK(date[, mode])</code></td>
<td>返回 <code>YYYYWW</code> 格式（年+周）</td>
<td><code>YEARWEEK(&#39;2025-12-07&#39;)</code> → <code>202549</code></td>
</tr>
</tbody></table>
<blockquote>
<p> 推荐用 <code>WEEK(date, 1)</code>：<strong>周一为每周首日</strong>，第1周需 &gt;&#x3D;4 天（ISO 标准兼容）。</p>
</blockquote>
<hr>
<h3><span id="三-日期时间格式化与解析">三、日期时间格式化与解析</span></h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>DATE_FORMAT(date, format)</code></td>
<td>按格式输出日期字符串</td>
<td><code>DATE_FORMAT(NOW(), &#39;%Y年%m月%d日 %H:%i&#39;)</code> → <code>&#39;2025年12月07日 15:30&#39;</code></td>
</tr>
<tr>
<td><code>TIME_FORMAT(time, format)</code></td>
<td>按格式输出时间字符串</td>
<td><code>TIME_FORMAT(&#39;15:30:45&#39;, &#39;%H时%i分&#39;)</code> → <code>&#39;15时30分&#39;</code></td>
</tr>
<tr>
<td><code>STR_TO_DATE(str, format)</code></td>
<td>按格式将字符串转为日期&#x2F;时间</td>
<td><code>STR_TO_DATE(&#39;2025/12/07&#39;, &#39;%Y/%m/%d&#39;)</code> → <code>&#39;2025-12-07&#39;</code></td>
</tr>
</tbody></table>
<h4><span id="常用格式符date_format-x2f-str_to_date">常用格式符（<code>DATE_FORMAT</code> &#x2F; <code>STR_TO_DATE</code>）</span></h4><table>
<thead>
<tr>
<th>格式符</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>%Y</code></td>
<td>4 位年</td>
<td><code>2025</code></td>
</tr>
<tr>
<td><code>%y</code></td>
<td>2 位年</td>
<td><code>25</code></td>
</tr>
<tr>
<td><code>%m</code></td>
<td>2 位月（01–12）</td>
<td><code>12</code></td>
</tr>
<tr>
<td><code>%c</code></td>
<td>月（1–12，无前导零）</td>
<td><code>12</code></td>
</tr>
<tr>
<td><code>%d</code></td>
<td>2 位日（01–31）</td>
<td><code>07</code></td>
</tr>
<tr>
<td><code>%e</code></td>
<td>日（1–31，无前导零）</td>
<td><code>7</code></td>
</tr>
<tr>
<td><code>%H</code></td>
<td>24 小时制（00–23）</td>
<td><code>15</code></td>
</tr>
<tr>
<td><code>%h</code> &#x2F; <code>%I</code></td>
<td>12 小时制（01–12）</td>
<td><code>03</code></td>
</tr>
<tr>
<td><code>%i</code></td>
<td>分钟（00–59）</td>
<td><code>30</code></td>
</tr>
<tr>
<td><code>%s</code> &#x2F; <code>%S</code></td>
<td>秒（00–59）</td>
<td><code>45</code></td>
</tr>
<tr>
<td><code>%p</code></td>
<td>AM&#x2F;PM</td>
<td><code>PM</code></td>
</tr>
<tr>
<td><code>%W</code></td>
<td>星期名（英文全称）</td>
<td><code>Sunday</code></td>
</tr>
<tr>
<td><code>%a</code></td>
<td>星期缩写</td>
<td><code>Sun</code></td>
</tr>
<tr>
<td><code>%M</code></td>
<td>月名（英文全称）</td>
<td><code>December</code></td>
</tr>
<tr>
<td><code>%b</code></td>
<td>月缩写</td>
<td><code>Dec</code></td>
</tr>
</tbody></table>
<blockquote>
<p> 示例：中文日期格式  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATE_FORMAT(NOW(), <span class="string">&#x27;%Y年%m月%d日 %W %H:%i&#x27;</span>);</span><br><span class="line"><span class="comment">-- 输出：2025年12月07日 Sunday 15:30</span></span><br></pre></td></tr></table></figure></blockquote>
<hr>
<h3><span id="四-日期时间运算加减间隔">四、日期时间运算（加减间隔）</span></h3><h4><span id="核心函数date_add-x2f-date_sub-x2f-interval">核心函数：<code>DATE_ADD()</code> &#x2F; <code>DATE_SUB()</code> &#x2F; <code>INTERVAL</code></span></h4><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>DATE_ADD(date, INTERVAL expr unit)</code></td>
<td>日期加间隔</td>
<td><code>DATE_ADD(&#39;2025-12-07&#39;, INTERVAL 3 DAY)</code> → <code>&#39;2025-12-10&#39;</code></td>
</tr>
<tr>
<td><code>DATE_SUB(date, INTERVAL expr unit)</code></td>
<td>日期减间隔</td>
<td><code>DATE_SUB(NOW(), INTERVAL 1 HOUR)</code> → 1 小时前</td>
</tr>
<tr>
<td><code>date + INTERVAL expr unit</code></td>
<td>等价于 <code>DATE_ADD</code>（更简洁）</td>
<td><code>CURDATE() + INTERVAL 7 DAY</code> → 7 天后</td>
</tr>
<tr>
<td><code>date - INTERVAL expr unit</code></td>
<td>等价于 <code>DATE_SUB</code></td>
<td><code>NOW() - INTERVAL 30 MINUTE</code> → 30 分钟前</td>
</tr>
</tbody></table>
<h4><span id="支持的-unit-类型常用">支持的 <code>unit</code> 类型（常用）</span></h4><table>
<thead>
<tr>
<th>单位</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>DAY</code>, <code>HOUR</code>, <code>MINUTE</code>, <code>SECOND</code></td>
<td>日、时、分、秒</td>
<td><code>INTERVAL 2 HOUR</code></td>
</tr>
<tr>
<td><code>WEEK</code>, <code>MONTH</code>, <code>QUARTER</code>, <code>YEAR</code></td>
<td>周、月、季、年</td>
<td><code>INTERVAL 1 MONTH</code></td>
</tr>
<tr>
<td><code>DAY_HOUR</code></td>
<td><code>&#39;天 小时&#39;</code> 格式</td>
<td><code>INTERVAL &#39;2 05&#39; DAY_HOUR</code> → 2天5小时</td>
</tr>
<tr>
<td><code>HOUR_MINUTE</code></td>
<td><code>&#39;小时:分&#39;</code> 格式</td>
<td><code>INTERVAL &#39;1:30&#39; HOUR_MINUTE</code> → 1小时30分</td>
</tr>
<tr>
<td><code>MINUTE_SECOND</code></td>
<td><code>&#39;分:秒&#39;</code> 格式</td>
<td><code>INTERVAL &#39;30:15&#39; MINUTE_SECOND</code> → 30分15秒</td>
</tr>
<tr>
<td><code>YEAR_MONTH</code></td>
<td><code>&#39;年-月&#39;</code> 格式</td>
<td><code>INTERVAL &#39;1-6&#39; YEAR_MONTH</code> → 1年6个月</td>
</tr>
</tbody></table>
<blockquote>
<p> 示例：获取本月第一天&#x2F;最后一天  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 本月第一天</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_FORMAT(CURDATE(), <span class="string">&#x27;%Y-%m-01&#x27;</span>);</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">SELECT</span> CURDATE() <span class="operator">-</span> <span class="type">INTERVAL</span> DAYOFMONTH(CURDATE())<span class="number">-1</span> <span class="keyword">DAY</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 本月最后一天（MySQL 8.0+ 推荐）</span></span><br><span class="line"><span class="keyword">SELECT</span> LAST_DAY(CURDATE());</span><br><span class="line"><span class="comment">-- 兼容旧版：</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_ADD(DATE_FORMAT(CURDATE(), <span class="string">&#x27;%Y-%m-01&#x27;</span>), <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">MONTH</span>) <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">DAY</span>;</span><br></pre></td></tr></table></figure></blockquote>
<hr>
<h3><span id="五-日期差值计算">五、日期差值计算</span></h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>DATEDIFF(expr1, expr2)</code></td>
<td><strong>日期差（天数）</strong>，忽略时间部分</td>
<td><code>DATEDIFF(&#39;2025-12-10&#39;, &#39;2025-12-07&#39;)</code> → <code>3</code></td>
</tr>
<tr>
<td><code>TIMEDIFF(expr1, expr2)</code></td>
<td><strong>时间差（TIME 类型）</strong>，仅限 <code>TIME</code> 或同日 <code>DATETIME</code></td>
<td><code>TIMEDIFF(&#39;15:30:00&#39;, &#39;14:00:00&#39;)</code> → <code>&#39;01:30:00&#39;</code></td>
</tr>
<tr>
<td><code>TIMESTAMPDIFF(unit, datetime1, datetime2)</code></td>
<td><strong>按指定单位计算差值</strong>（更灵活）</td>
<td><code>TIMESTAMPDIFF(HOUR, &#39;2025-12-07 10:00&#39;, NOW())</code> → 相差小时数</td>
</tr>
</tbody></table>
<blockquote>
<p> <code>TIMESTAMPDIFF</code> 的 <code>unit</code>：<code>YEAR</code>, <code>QUARTER</code>, <code>MONTH</code>, <code>WEEK</code>, <code>DAY</code>, <code>HOUR</code>, <code>MINUTE</code>, <code>SECOND</code><br> 示例：计算年龄（精确到月）  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  name,</span><br><span class="line">  TIMESTAMPDIFF(<span class="keyword">YEAR</span>, birth_date, CURDATE()) <span class="keyword">AS</span> age_years,</span><br><span class="line">  TIMESTAMPDIFF(<span class="keyword">MONTH</span>, birth_date, CURDATE()) <span class="operator">%</span> <span class="number">12</span> <span class="keyword">AS</span> extra_months</span><br><span class="line"><span class="keyword">FROM</span> users;</span><br></pre></td></tr></table></figure></blockquote>
<hr>
<h3><span id="六-其他实用函数">六、其他实用函数</span></h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>LAST_DAY(date)</code></td>
<td>返回该月最后一天</td>
<td><code>LAST_DAY(&#39;2025-02-10&#39;)</code> → <code>&#39;2025-02-28&#39;</code></td>
</tr>
<tr>
<td><code>MAKEDATE(year, dayofyear)</code></td>
<td>用年份 + 年内第几天构造日期</td>
<td><code>MAKEDATE(2025, 341)</code> → <code>&#39;2025-12-07&#39;</code></td>
</tr>
<tr>
<td><code>MAKETIME(hour, minute, second)</code></td>
<td>构造时间</td>
<td><code>MAKETIME(15, 30, 45)</code> → <code>&#39;15:30:45&#39;</code></td>
</tr>
<tr>
<td><code>FROM_DAYS(N)</code></td>
<td>将天数（自公元0年1月1日起）转为日期</td>
<td><code>FROM_DAYS(738864)</code> → <code>&#39;2025-12-07&#39;</code></td>
</tr>
<tr>
<td><code>TO_DAYS(date)</code></td>
<td>日期转天数（同上）</td>
<td><code>TO_DAYS(&#39;2025-12-07&#39;)</code> → <code>738864</code></td>
</tr>
</tbody></table>
<hr>
<h2><span id="数学类函数">数学类函数</span></h2><hr>
<h3><span id="一-基础算术与取整">一、基础算术与取整</span></h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>示例</th>
<th>返回类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>ABS(X)</code></td>
<td>绝对值</td>
<td><code>ABS(-5.3)</code> → <code>5.3</code></td>
<td>与输入一致（<code>DECIMAL</code>&#x2F;<code>DOUBLE</code>&#x2F;<code>BIGINT</code>）</td>
</tr>
<tr>
<td><code>SIGN(X)</code></td>
<td>符号：正→<code>1</code>，负→<code>-1</code>，零→<code>0</code></td>
<td><code>SIGN(-10)</code> → <code>-1</code></td>
<td>整数</td>
</tr>
<tr>
<td><code>MOD(N, M)</code><br><code>N % M</code><br><code>N MOD M</code></td>
<td>取模（余数）</td>
<td><code>MOD(17, 5)</code> → <code>2</code><br><code>MOD(-17, 5)</code> → <code>-2</code></td>
<td>同 <code>N</code></td>
</tr>
<tr>
<td><code>FLOOR(X)</code></td>
<td>向下取整（≤ X 的最大整数）</td>
<td><code>FLOOR(3.9)</code> → <code>3</code><br><code>FLOOR(-2.1)</code> → <code>-3</code></td>
<td>整数</td>
</tr>
<tr>
<td><code>CEIL(X)</code> &#x2F; <code>CEILING(X)</code></td>
<td>向上取整（≥ X 的最小整数）</td>
<td><code>CEIL(3.1)</code> → <code>4</code><br><code>CEIL(-2.1)</code> → <code>-2</code></td>
<td>整数</td>
</tr>
<tr>
<td><code>ROUND(X)</code><br><code>ROUND(X, D)</code></td>
<td>四舍五入；<code>D</code> 为小数位（默认 0）<br><strong>注意：当小数位为 5 时，向最近偶数取整（银行家舍入）</strong></td>
<td><code>ROUND(2.5)</code> → <code>2</code><br><code>ROUND(3.5)</code> → <code>4</code><br><code>ROUND(123.456, 2)</code> → <code>123.46</code><br><code>ROUND(123.456, -1)</code> → <code>120</code></td>
<td>同输入（<code>D=0</code> 时为整数）</td>
</tr>
<tr>
<td><code>TRUNCATE(X, D)</code></td>
<td>截断（直接舍弃，<strong>不四舍五入</strong>）</td>
<td><code>TRUNCATE(3.999, 2)</code> → <code>3.99</code><br><code>TRUNCATE(123, -1)</code> → <code>120</code></td>
<td>同输入</td>
</tr>
</tbody></table>
<blockquote>
<p> <code>ROUND</code> 的“银行家舍入”说明：<br><code>ROUND(1.5) = 2</code>，<code>ROUND(2.5) = 2</code>，<code>ROUND(3.5) = 4</code> —— 避免统计偏差。</p>
</blockquote>
<hr>
<h3><span id="二-幂-指数与对数">二、幂、指数与对数</span></h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>POW(X, Y)</code> &#x2F; <code>POWER(X, Y)</code></td>
<td>X 的 Y 次方</td>
<td><code>POW(2, 3)</code> → <code>8</code><br><code>POW(25, 0.5)</code> → <code>5</code>（开方）</td>
</tr>
<tr>
<td><code>SQRT(X)</code></td>
<td>平方根（X ≥ 0）</td>
<td><code>SQRT(16)</code> → <code>4</code></td>
</tr>
<tr>
<td><code>EXP(X)</code></td>
<td>e<sup>X</sup>（自然指数）</td>
<td><code>EXP(1)</code> ≈ <code>2.718281828459045</code></td>
</tr>
<tr>
<td><code>LN(X)</code></td>
<td>自然对数（log<sub>e</sub>X，X &gt; 0）</td>
<td><code>LN(EXP(2))</code> → <code>2</code></td>
</tr>
<tr>
<td><code>LOG(X)</code></td>
<td>同 <code>LN(X)</code></td>
<td><code>LOG(2.71828)</code> ≈ <code>1</code></td>
</tr>
<tr>
<td><code>LOG(B, X)</code></td>
<td>以 B 为底的对数（B &gt; 0, B ≠ 1, X &gt; 0）</td>
<td><code>LOG(2, 8)</code> → <code>3</code></td>
</tr>
<tr>
<td><code>LOG2(X)</code></td>
<td>以 2 为底对数（常用于信息熵、位运算）</td>
<td><code>LOG2(1024)</code> → <code>10</code></td>
</tr>
<tr>
<td><code>LOG10(X)</code></td>
<td>以 10 为底对数（常用对数）</td>
<td><code>LOG10(1000)</code> → <code>3</code></td>
</tr>
</tbody></table>
<blockquote>
<p> 输入为负或零时，对数函数返回 <code>NULL</code> 并警告。</p>
</blockquote>
<hr>
<h3><span id="三-三角函数弧度制">三、三角函数（<strong>弧度制</strong>）</span></h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>PI()</code></td>
<td>返回 π（≈ 3.141593）</td>
<td><code>PI()</code> → <code>3.141593</code></td>
</tr>
<tr>
<td><code>SIN(X)</code></td>
<td>正弦（X 为弧度）</td>
<td><code>SIN(PI()/2)</code> → <code>1</code></td>
</tr>
<tr>
<td><code>COS(X)</code></td>
<td>余弦</td>
<td><code>COS(0)</code> → <code>1</code></td>
</tr>
<tr>
<td><code>TAN(X)</code></td>
<td>正切</td>
<td><code>TAN(PI()/4)</code> → <code>1</code></td>
</tr>
<tr>
<td><code>ASIN(X)</code></td>
<td>反正弦（值域 [-1,1]）</td>
<td><code>ASIN(1)</code> → <code>1.570796</code>（≈π&#x2F;2）</td>
</tr>
<tr>
<td><code>ACOS(X)</code></td>
<td>反余弦（值域 [-1,1]）</td>
<td><code>ACOS(0)</code> → <code>1.570796</code></td>
</tr>
<tr>
<td><code>ATAN(X)</code></td>
<td>反正切（单参数）</td>
<td><code>ATAN(1)</code> → <code>0.785398</code>（≈π&#x2F;4）</td>
</tr>
<tr>
<td><code>ATAN(Y, X)</code> &#x2F; <code>ATAN2(Y, X)</code></td>
<td>四象限反正切（推荐用 <code>ATAN2</code>）</td>
<td><code>ATAN2(1, 1)</code> → <code>0.785398</code><br><code>ATAN2(-1, -1)</code> → <code>-2.356194</code>（第三象限）</td>
</tr>
<tr>
<td><code>COT(X)</code></td>
<td>余切 &#x3D; 1 &#x2F; TAN(X)</td>
<td><code>COT(PI()/4)</code> → <code>1</code></td>
</tr>
<tr>
<td><code>DEGREES(X)</code></td>
<td>弧度 → 角度</td>
<td><code>DEGREES(PI())</code> → <code>180</code></td>
</tr>
<tr>
<td><code>RADIANS(X)</code></td>
<td>角度 → 弧度</td>
<td><code>RADIANS(90)</code> → <code>1.570796</code></td>
</tr>
</tbody></table>
<blockquote>
<p> 角度计算模板：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 计算 30 度的正弦值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SIN</span>(RADIANS(<span class="number">30</span>));  <span class="comment">-- → 0.5</span></span><br></pre></td></tr></table></figure></blockquote>
<hr>
<h3><span id="四-随机数">四、随机数</span></h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>RAND()</code></td>
<td>返回 <strong>[0, 1)</strong> 的随机浮点数</td>
<td><code>SELECT RAND();</code> → <code>0.7321...</code></td>
</tr>
<tr>
<td><code>RAND(N)</code></td>
<td>用种子 <code>N</code> 初始化随机数生成器，之后调用 <code>RAND()</code> 可重现序列</td>
<td><code>SELECT RAND(1), RAND(), RAND();</code><br>→ 每次执行结果相同</td>
</tr>
</tbody></table>
<h4><span id="常用随机数生成公式">常用随机数生成公式</span></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- [a, b] 区间随机整数（含端点）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">FLOOR</span>(a <span class="operator">+</span> RAND() <span class="operator">*</span> (b <span class="operator">-</span> a <span class="operator">+</span> <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 示例：生成 [1, 100] 随机整数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">FLOOR</span>(<span class="number">1</span> <span class="operator">+</span> RAND() <span class="operator">*</span> <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 生成 6 位随机数字验证码</span></span><br><span class="line"><span class="keyword">SELECT</span> LPAD(<span class="built_in">FLOOR</span>(RAND() <span class="operator">*</span> <span class="number">1000000</span>), <span class="number">6</span>, <span class="string">&#x27;0&#x27;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h3><span id="五-进制与位运算辅助部分">五、进制与位运算辅助（部分）</span></h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>BIN(N)</code></td>
<td>十进制 → 二进制字符串</td>
<td><code>BIN(10)</code> → <code>&#39;1010&#39;</code></td>
</tr>
<tr>
<td><code>OCT(N)</code></td>
<td>十进制 → 八进制字符串</td>
<td><code>OCT(9)</code> → <code>&#39;11&#39;</code></td>
</tr>
<tr>
<td><code>HEX(N)</code></td>
<td>十进制 → 十六进制字符串</td>
<td><code>HEX(255)</code> → <code>&#39;FF&#39;</code></td>
</tr>
<tr>
<td><code>CONV(N, from_base, to_base)</code></td>
<td>任意进制转换（2~36 进制）</td>
<td><code>CONV(&#39;FF&#39;, 16, 10)</code> → <code>&#39;255&#39;</code><br><code>CONV(&#39;1010&#39;, 2, 16)</code> → <code>&#39;A&#39;</code></td>
</tr>
</tbody></table>
<blockquote>
<p> 注意：<code>BIN()</code>, <code>HEX()</code> 等返回的是<strong>字符串</strong>，不是数值。</p>
</blockquote>
<hr>
<h3><span id="六-聚合中的数学应用补充">六、聚合中的数学应用（补充）</span></h3><p>虽属聚合函数，但常与数学结合：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  <span class="built_in">AVG</span>(score) <span class="keyword">AS</span> avg_score,</span><br><span class="line">  <span class="built_in">STDDEV_POP</span>(score) <span class="keyword">AS</span> population_std,  <span class="comment">-- 总体标准差</span></span><br><span class="line">  <span class="built_in">STDDEV_SAMP</span>(score) <span class="keyword">AS</span> sample_std,      <span class="comment">-- 样本标准差（更常用）</span></span><br><span class="line">  VARIANCE(score) <span class="keyword">AS</span> variance,</span><br><span class="line">  <span class="comment">-- 百分位（MySQL 8.0+）</span></span><br><span class="line">  <span class="built_in">PERCENT_RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> score) <span class="keyword">AS</span> pct_rank</span><br><span class="line"><span class="keyword">FROM</span> scores;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> <code>STDDEV_POP</code> vs <code>STDDEV_SAMP</code>：  </p>
<ul>
<li>总体标准差：分母为 <code>N</code>  </li>
<li>样本标准差：分母为 <code>N-1</code>（无偏估计）</li>
</ul>
</blockquote>
<hr>
<h3><span id="附常见错误与注意事项">附：常见错误与注意事项</span></h3><table>
<thead>
<tr>
<th>问题</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ROUND(2.5)</code> ≠ 3</td>
<td>因采用<strong>银行家舍入</strong>（向最近偶数取整）</td>
</tr>
<tr>
<td><code>MOD(-7, 3)</code> &#x3D; <code>-1</code></td>
<td>MySQL 中 <code>MOD(a,b)</code> 符号与 <code>a</code> 一致（不同于 Python）</td>
</tr>
<tr>
<td>三角函数输入为角度</td>
<td>必须先用 <code>RADIANS()</code> 转换</td>
</tr>
<tr>
<td><code>LOG(0)</code> &#x2F; <code>LOG(-1)</code></td>
<td>返回 <code>NULL</code>（对数定义域限制）</td>
</tr>
<tr>
<td><code>SQRT(-1)</code></td>
<td>返回 <code>NULL</code>（实数域无解）</td>
</tr>
</tbody></table>
<hr>
<h2><span id="加密函数">加密函数</span></h2><ol>
<li>USER() 查询用户</li>
<li>DATABASE() 当前数据库名称</li>
<li>MD5(str)</li>
<li>PASSWORD(str)</li>
<li>SELECT * FROM mysql.user \G</li>
</ol>
<h2><span id="流程控制函数">流程控制函数</span></h2><ol>
<li>IF</li>
<li>IFNULL</li>
<li>SELECT CASE XX THEN XX</li>
</ol>
<h2><span id="查询增强">查询增强</span></h2><ul>
<li>LIKE % 表示0到多个字符 、 - 表示单个字符</li>
</ul>
<h2><span id="分页查询">分页查询</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT XXX LIMIT START, LOWS</span><br></pre></td></tr></table></figure>
<p>从start + 1 开始，取rows行</p>
<p>公式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIMIT 每页显示数 * 第几页 - 1，每页显示数</span><br></pre></td></tr></table></figure>

<h2><span id="多表查询">多表查询</span></h2><h3><span id="直接查询两张表">直接查询两张表</span></h3><p>从第一张表N取一行与第二张表M每一行进行组合，一共返回 N * M 行</p>
<h3><span id="解决方法">解决方法</span></h3><p>WHERE 过滤</p>
<p>注：查询条件不能少于 表数 - 1，否则会出现笛卡尔积</p>
<p>若表 A 有 1万 行，表 B 有 1万 行，笛卡尔积就是 1亿行</p>
<h2><span id="自连接">自连接</span></h2><ol>
<li>把一张表当两张表用</li>
<li>需要给表起别名</li>
</ol>
<h2><span id="子查询">子查询</span></h2><h3><span id="单行子查询">单行子查询</span></h3><p>子查询返回 0 行或 1 行（即至多一行结果）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查询工资高于平均工资的员工</span><br><span class="line">SELECT name, salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &gt; (SELECT AVG(salary) FROM employees);  -- ← 单行子查询（AVG 返回一个值）</span><br></pre></td></tr></table></figure>
<h3><span id="多行子查询">多行子查询</span></h3><ul>
<li>必须配合多行操作符使用</li>
</ul>
<p>常用操作符：</p>
<ul>
<li>IN：等于列表中任意一个值</li>
<li>NOT IN：不等于列表中所有值</li>
<li>ANY &#x2F; SOME：与子查询结果中的任意一个比较为真即满足</li>
<li>ALL：与子查询结果中的所有值比较都为真才满足</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 查询工资高于“任一”经理工资的员工</span><br><span class="line">SELECT name, salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &gt; ANY (</span><br><span class="line">    SELECT salary FROM employees WHERE job_title = &#x27;经理&#x27;</span><br><span class="line">);</span><br><span class="line">-- 等价于：salary &gt; (子查询中最小的经理工资)</span><br></pre></td></tr></table></figure>
<h3><span id="多列子查询">多列子查询</span></h3><p>返回多个列数据的子查询语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 高薪岗位定义：salary &gt; 10000 的 (dept_id, job_title) 组合</span><br><span class="line">SELECT name, dept_id, job_title</span><br><span class="line">FROM employees</span><br><span class="line">WHERE (dept_id, job_title) IN (</span><br><span class="line">    SELECT dept_id, job_title</span><br><span class="line">    FROM employees</span><br><span class="line">    WHERE salary &gt; 10000</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>数据库会把 (col1, col2) 视为一个逻辑元组（tuple） 进行匹配。</p>
<h2><span id="表复制">表复制</span></h2><h3><span id="只复制表结构">只复制表结构</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE new_table LIKE old_table;</span><br></pre></td></tr></table></figure>
<h3><span id="复制全部数据">复制全部数据</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE new_table AS</span><br><span class="line">SELECT * FROM old_table;</span><br></pre></td></tr></table></figure>
<h2><span id="合并查询">合并查询</span></h2><p>“<strong>合并查询</strong>”在 SQL 中通常指将<strong>多个查询结果集纵向拼接</strong>为一个结果集，核心语法是 <code>UNION</code>、<code>UNION ALL</code>、<code>INTERSECT</code>、<code>EXCEPT</code>（或 <code>MINUS</code>）。下面以标准 SQL 为主，结合主流数据库（MySQL &#x2F; PostgreSQL &#x2F; Oracle &#x2F; SQL Server）差异，系统讲解：</p>
<hr>
<h2><span id="一-核心操作符对比">✅ 一、核心操作符对比</span></h2><table>
<thead>
<tr>
<th>操作符</th>
<th>作用</th>
<th>去重？</th>
<th>排序？</th>
<th>MySQL</th>
<th>PostgreSQL</th>
<th>SQL Server</th>
<th>Oracle</th>
</tr>
</thead>
<tbody><tr>
<td><code>UNION</code></td>
<td>合并结果，<strong>去重</strong></td>
<td>✅</td>
<td>✅（隐式按列排序）</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
</tr>
<tr>
<td><code>UNION ALL</code></td>
<td>合并结果，<strong>保留重复</strong></td>
<td>❌</td>
<td>❌（保持原顺序）</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
</tr>
<tr>
<td><code>INTERSECT</code></td>
<td>取多个查询<strong>交集</strong>（都存在的行）</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
</tr>
<tr>
<td><code>EXCEPT</code> &#x2F; <code>MINUS</code></td>
<td>取<strong>差集</strong>（第一查询有、后续没有的行）</td>
<td>✅</td>
<td>✅</td>
<td>❌（可用 <code>NOT EXISTS</code> 替代）</td>
<td><code>EXCEPT</code> ✔️</td>
<td><code>EXCEPT</code> ✔️</td>
<td><code>MINUS</code> ✔️</td>
</tr>
</tbody></table>
<blockquote>
<p>🔔 MySQL 不支持 <code>INTERSECT</code> 和 <code>EXCEPT</code>，需用 <code>INNER JOIN</code> &#x2F; <code>NOT EXISTS</code> 模拟（后文给出方案）。</p>
</blockquote>
<hr>
<h2><span id="二-union-与-union-all">二、<code>UNION</code> 与 <code>UNION ALL</code></span></h2><h3><span id="基本规则">基本规则</span></h3><ol>
<li><strong>列数必须相同</strong>；</li>
<li><strong>对应列数据类型需兼容</strong>（如 <code>INT</code> + <code>VARCHAR</code> 可能隐式转换）；</li>
<li><strong>结果集列名取自第一个查询</strong>；</li>
<li>每个 <code>SELECT</code> 可独立使用 <code>WHERE</code>、<code>GROUP BY</code>、<code>HAVING</code>，但<strong>不能单独用 <code>ORDER BY</code>（除非加括号+LIMIT）</strong>。</li>
</ol>
<hr>
<h3><span id="示例合并销售数据按季度分表">示例：合并销售数据（按季度分表）</span></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 合并 Q1、Q2 销售记录，去重（如避免重复录入）</span></span><br><span class="line"><span class="keyword">SELECT</span> product, amount, <span class="string">&#x27;Q1&#x27;</span> <span class="keyword">AS</span> quarter</span><br><span class="line"><span class="keyword">FROM</span> sales_q1</span><br><span class="line"><span class="keyword">WHERE</span> amount <span class="operator">&gt;</span> <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">UNION</span>  <span class="comment">-- ← 自动去重 + 排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> product, amount, <span class="string">&#x27;Q2&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> sales_q2</span><br><span class="line"><span class="keyword">WHERE</span> amount <span class="operator">&gt;</span> <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> amount <span class="keyword">DESC</span>;  <span class="comment">-- 全局排序</span></span><br></pre></td></tr></table></figure>

<h3><span id="union-all-高性能场景"><code>UNION ALL</code> 高性能场景</span></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 日志按天分表，合并最近3天（无需去重）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> log_20251206</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> log_20251207</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> log_20251208;</span><br></pre></td></tr></table></figure>
<ul>
<li>⚡ 比 <code>UNION</code> 快 5~10 倍（省去排序+去重开销）；</li>
<li>适合：分区表合并、ETL 临时表整合、大数据分析。</li>
</ul>
<hr>
<h2><span id="三-交集-inner-join-或-in">✅ 三、交集 <code>INNER JOIN</code> 或 <code>IN</code></span></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方案1：INNER JOIN（推荐，性能好）</span></span><br><span class="line"><span class="keyword">SELECT</span> v.user_id</span><br><span class="line"><span class="keyword">FROM</span> vip_users v</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> active_users a <span class="keyword">ON</span> v.user_id <span class="operator">=</span> a.user_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方案2：IN + 子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> user_id <span class="keyword">FROM</span> vip_users</span><br><span class="line"><span class="keyword">WHERE</span> user_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> user_id <span class="keyword">FROM</span> active_users);</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="四-差集-not-exists">四、差集 <code>NOT EXISTS</code></span></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> r.user_id</span><br><span class="line"><span class="keyword">FROM</span> registered_users r</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> orders o <span class="keyword">WHERE</span> o.user_id <span class="operator">=</span> r.user_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 避免用 <code>NOT IN</code>（若 <code>orders.user_id</code> 含 <code>NULL</code>，结果为空！）</p>
</blockquote>
<hr>
<h2><span id="五-高级技巧与注意事项">✅ 五、高级技巧与注意事项</span></h2><h3><span id="1️-为每个来源打标签">1️ 为每个来源打标签</span></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, email, <span class="string">&#x27;internal&#x27;</span> <span class="keyword">AS</span> source <span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> name, email, <span class="string">&#x27;external&#x27;</span> <span class="keyword">FROM</span> partners</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> source, name;</span><br></pre></td></tr></table></figure>

<h3><span id="2️-处理列类型不一致">2️ 处理列类型不一致</span></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 错误：INT vs VARCHAR</span></span><br><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> table2;  <span class="comment">--  可能报错或隐式转换失败</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正确：显式转换</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CAST</span>(id <span class="keyword">AS</span> <span class="type">CHAR</span>) <span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> table2;</span><br></pre></td></tr></table></figure>

<h3><span id="3️-子查询中使用-union">3️ 子查询中使用 <code>UNION</code></span></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> students</span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">    <span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> teachers</span><br><span class="line">) <span class="keyword">AS</span> all_people</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;张%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3><span id="4️-order-by-限制">4️ <code>ORDER BY</code> 限制</span></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--  错误：不能在中间 SELECT 加 ORDER BY</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t2;</span><br><span class="line"></span><br><span class="line"><span class="comment">--  正确1：全局排序</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1)</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t2)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id;</span><br><span class="line"></span><br><span class="line"><span class="comment">--  正确2：各子查询排序+LIMIT（需括号）</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">5</span>)</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t2 <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">DESC</span> LIMIT <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="六-性能优化建议">六、性能优化建议</span></h2><table>
<thead>
<tr>
<th>场景</th>
<th>建议</th>
</tr>
</thead>
<tbody><tr>
<td>大结果集合并</td>
<td>优先用 <code>UNION ALL</code>，避免无意义去重</td>
</tr>
<tr>
<td>需去重但数据量大</td>
<td>先 <code>UNION ALL</code> + 外层 <code>DISTINCT</code>，或用 <code>GROUP BY</code></td>
</tr>
<tr>
<td>多表 <code>UNION</code></td>
<td>确保各 <code>SELECT</code> 的 <code>WHERE</code> 条件能走索引</td>
</tr>
<tr>
<td>分页合并</td>
<td>在<strong>外层</strong>分页，而非每个子查询分页（否则逻辑错）</td>
</tr>
</tbody></table>
<h1><span id="约束">约束</span></h1><h2><span id="主键">主键</span></h2><ol>
<li>主键列的值不能重复 PRIMARY KEY</li>
<li>值不能为NULL</li>
<li>可以复合，但必须唯一</li>
<li>DESC 会显示主键</li>
</ol>
<h2><span id="unique">UNIQUE</span></h2><p>被添加的值不能重复</p>
<h2><span id="外键">外键</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FOREIGN KEY (外键) REFERENCES table (属性)</span><br></pre></td></tr></table></figure>
<ol>
<li>外键类型与主键要一致</li>
<li>外键指向主键或UNIQUE</li>
<li>外键字段的值，必须出现在主键中，或为空</li>
<li>建立主外键关系后，数据不能随意删除</li>
</ol>
<h2><span id="check">check</span></h2><p>MySQL5.7不支持，只做语法校验</p>
<h2><span id="自增长">自增长</span></h2><p>AUTO_INSERT</p>
<ul>
<li>自增长默认从1开始，但可修改</li>
<li>通常搭配主键或UNIQUE</li>
</ul>
<h1><span id="索引">索引</span></h1><h2><span id="mysql-索引底层结构b-树">MySQL 索引底层结构：B+ 树</span></h2><p>MySQL 默认（InnoDB 引擎）使用 <strong>B+ 树（B+ Tree）</strong> 实现索引，<strong>不是哈希，也不是普通二叉树</strong>。</p>
<h3><span id="b-树特点innodb">B+ 树特点（InnoDB）：</span></h3><table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>多路平衡查找树</strong></td>
<td>每个节点可存多个 key，树高度低（通常 3~4 层可存千万级数据）→ 减少磁盘 IO</td>
</tr>
<tr>
<td><strong>非叶子节点只存 key</strong></td>
<td>不存数据，只存索引导航信息，单页可存更多 key，树更矮</td>
</tr>
<tr>
<td><strong>叶子节点存完整数据</strong>（聚簇索引）或 <strong>主键值</strong>（二级索引）</td>
<td>叶子节点之间用<strong>双向链表</strong>连接 → 利于范围查询、排序</td>
</tr>
<tr>
<td><strong>数据按 key 顺序存储</strong></td>
<td>插入时可能分裂节点，但查询效率稳定</td>
</tr>
</tbody></table>
<p> <strong>示意图简化版</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">              [20, 50]               ← 根节点（内存中常驻）</span><br><span class="line">             /    |    \</span><br><span class="line">    [5,10,15]  [25,30,40]  [55,60,70]   ← 非叶子节点</span><br><span class="line">     / | | \     / | | \      / | | \</span><br><span class="line">[1..5]...[15..20] ... [70..∞]           ← 叶子节点（存数据或主键），双向链表连接</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 知识点：  </p>
<ul>
<li>一次查询 &#x3D; 树的高度次磁盘 IO（例如 3 层 → 3 次 IO）；  </li>
<li>全表扫描 &#x3D; 扫所有叶子节点（数据页）；  </li>
<li>范围查询（如 <code>WHERE id BETWEEN 10 AND 30</code>）只需在叶子节点链表上顺序遍历，效率高。</li>
</ul>
</blockquote>
<hr>
<h2><span id="mysql-索引类型按存储-amp-逻辑分">MySQL 索引类型（按存储 &amp; 逻辑分）</span></h2><h3><span id="1️-按存储结构分innodb-引擎">1️ 按存储结构分（InnoDB 引擎）</span></h3><table>
<thead>
<tr>
<th>类型</th>
<th>中文名</th>
<th>说明</th>
<th>是否必须？</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Clustered Index</strong></td>
<td><strong>聚簇索引</strong></td>
<td><strong>叶子节点直接存储整行数据</strong>。每个表<strong>只能有一个</strong>（因为数据只能按一种顺序物理存储）。InnoDB 中，<strong>主键就是聚簇索引</strong>！</td>
<td>✅ 是（无主键时，InnoDB 隐式创建 6 字节 row_id 作聚簇索引）</td>
</tr>
<tr>
<td><strong>Secondary Index</strong></td>
<td><strong>二级索引（辅助索引）</strong></td>
<td>叶子节点<strong>只存索引列 + 主键值</strong>。查数据时需“<strong>回表</strong>”（先查二级索引 → 拿主键 → 再查聚簇索引）。</td>
<td>❌ 按需创建</td>
</tr>
</tbody></table>
<h4><span id="举例表usersid-pk-name-age">举例（表：<code>users(id PK, name, age)</code>）</span></h4><ul>
<li><strong>聚簇索引</strong>：按 <code>id</code> 组织数据页 → 查 <code>WHERE id=100</code> → 1 次 IO 直接得数据。</li>
<li><strong>二级索引 <code>idx_name (name)</code></strong>：<ul>
<li>叶子节点存 <code>(name, id)</code>；</li>
<li>查 <code>WHERE name=&#39;Alice&#39;</code> → 先在 <code>idx_name</code> 找到 <code>&#39;Alice&#39;, id=500</code> → 再用 <code>id=500</code> 回表查聚簇索引 → <strong>2 次 IO</strong>（即“回表”）。</li>
</ul>
</li>
</ul>
<blockquote>
<p> 优化技巧：<strong>覆盖索引</strong>（Covering Index）<br>如果查询的列<strong>全部包含在索引中</strong>，就无需回表！  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建联合索引 (name, age)</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_name_age <span class="keyword">ON</span> users(name, age);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询只涉及 name 和 age → 直接从索引取数据，不回表！</span></span><br><span class="line"><span class="keyword">SELECT</span> name, age <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span>;</span><br></pre></td></tr></table></figure></blockquote>
<hr>
<h3><span id="2️-按逻辑功能分常用">2️ 按逻辑功能分（常用）</span></h3><table>
<thead>
<tr>
<th>类型</th>
<th>语法</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>主键索引（PRIMARY KEY）</strong></td>
<td><code>PRIMARY KEY (id)</code></td>
<td>唯一、非空、聚簇索引</td>
<td>每表必有（显式或隐式）</td>
</tr>
<tr>
<td><strong>唯一索引（UNIQUE）</strong></td>
<td><code>UNIQUE KEY (email)</code></td>
<td>值唯一（可 NULL，但只能一个 NULL）</td>
<td>身份证号、邮箱等唯一字段</td>
</tr>
<tr>
<td><strong>普通索引（INDEX &#x2F; KEY）</strong></td>
<td><code>INDEX idx_age (age)</code></td>
<td>无限制，可重复、可 NULL</td>
<td>高频查询字段（如状态、分类）</td>
</tr>
<tr>
<td><strong>联合索引（Composite Index）</strong></td>
<td><code>INDEX idx_a_b_c (a, b, c)</code></td>
<td>多列组合，<strong>最左前缀原则</strong>生效</td>
<td>组合查询（如 <code>WHERE a=? AND b=?</code>）</td>
</tr>
<tr>
<td><strong>前缀索引</strong></td>
<td><code>INDEX idx_url (url(20))</code></td>
<td>只索引字符串前 N 字符，省空间</td>
<td>长文本（URL、描述），但可能降低区分度</td>
</tr>
<tr>
<td><strong>全文索引（FULLTEXT）</strong></td>
<td><code>FULLTEXT (content)</code></td>
<td>支持 <code>MATCH ... AGAINST</code> 模糊搜索</td>
<td>文章内容、评论搜索（MyISAM &#x2F; InnoDB ≥ 5.6）</td>
</tr>
<tr>
<td><strong>空间索引（SPATIAL）</strong></td>
<td><code>SPATIAL INDEX (geom)</code></td>
<td>用于地理数据（POINT, POLYGON）</td>
<td>GIS 应用</td>
</tr>
</tbody></table>
<hr>
<h2><span id="联合索引-amp-最左前缀原则面试高频">联合索引 &amp; 最左前缀原则（面试高频！）</span></h2><p>这是<strong>高效使用索引的关键</strong>！</p>
<h3><span id="规则">规则：</span></h3><p>对联合索引 <code>(a, b, c)</code>：</p>
<ul>
<li><code>WHERE a = 1</code> → <strong>用索引</strong></li>
<li><code>WHERE a = 1 AND b = 2</code> → <strong>用索引</strong></li>
<li><code>WHERE a = 1 AND b = 2 AND c = 3</code> → <strong>用索引</strong></li>
<li><code>WHERE a = 1 AND c = 3</code> → <strong>只用到 a</strong>（b 跳过，c 无效）</li>
<li>❌ <code>WHERE b = 2</code> → <strong>索引失效</strong></li>
<li>❌ <code>WHERE c = 3</code> → <strong>索引失效</strong></li>
<li><code>WHERE a = 1 AND b &gt; 2 AND c = 3</code> → <strong>用到 a, b</strong>（c 无法用，因 b 是范围查询）</li>
</ul>
<blockquote>
<p> <strong>原理</strong>：B+ 树先按 <code>a</code> 排序，<code>a</code> 相同再按 <code>b</code>，再按 <code>c</code>。<br>就像字典：先按首字母（a），再按第二字母（b）…… 要查“apple”，必须从 ‘a’ 开始；若直接查“pple”，无法定位。</p>
</blockquote>
<h3><span id="正确建联合索引顺序">正确建联合索引顺序：</span></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询常为：WHERE status = &#x27;active&#x27; AND create_time &gt; &#x27;2024-01-01&#x27; ORDER BY user_id</span></span><br><span class="line"><span class="comment">--  好顺序：(status, create_time, user_id)</span></span><br><span class="line"><span class="comment">-- 理由：</span></span><br><span class="line"><span class="comment">--   status = 常量 → 精准定位</span></span><br><span class="line"><span class="comment">--   create_time &gt; 范围 → 可继续用索引范围扫描</span></span><br><span class="line"><span class="comment">--   user_id → 用于 ORDER BY，避免 filesort</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_status_time_user <span class="keyword">ON</span> orders(status, create_time, user_id);</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="如何判断索引是否生效explain">如何判断索引是否生效？——<code>EXPLAIN</code></span></h2><p>这是<strong>调试索引的必备工具</strong>！</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>重点关注字段：</p>
<table>
<thead>
<tr>
<th>列</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>type</code></td>
<td>访问类型：<code>system</code> &gt; <code>const</code> &gt; <code>eq_ref</code> &gt; <code>ref</code> &gt; <code>range</code> &gt; <code>index</code> &gt; <code>ALL</code>（越靠左越好，<code>ALL</code>&#x3D;全表扫描）</td>
</tr>
<tr>
<td><code>key</code></td>
<td>实际使用的索引名</td>
</tr>
<tr>
<td><code>key_len</code></td>
<td>使用的索引长度（可判断联合索引用到几列）</td>
</tr>
<tr>
<td><code>rows</code></td>
<td>预估扫描行数（越少越好）</td>
</tr>
<tr>
<td><code>Extra</code></td>
<td>额外信息：<br>✅ <code>Using index</code> → 覆盖索引（不回表）<br>⚠️ <code>Using filesort</code> → 内存&#x2F;磁盘排序（慢）<br>⚠️ <code>Using temporary</code> → 用了临时表（慢）</td>
</tr>
</tbody></table>
<p> 示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> name, age <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span>;</span><br><span class="line"><span class="comment">-- 若 key = idx_name_age, Extra = &quot;Using index&quot; → 完美覆盖索引！</span></span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="索引失效的常见场景避坑指南">索引失效的常见场景（避坑指南！）</span></h2><table>
<thead>
<tr>
<th>场景</th>
<th>原因</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td><strong>对字段做函数&#x2F;运算</strong></td>
<td><code>WHERE YEAR(create_time) = 2024</code></td>
<td>改写为范围：<code>WHERE create_time BETWEEN &#39;2024-01-01&#39; AND &#39;2024-12-31&#39;</code></td>
</tr>
<tr>
<td><strong>隐式类型转换</strong></td>
<td><code>WHERE phone = 13800138000</code>（phone 是 VARCHAR）</td>
<td>加引号：<code>WHERE phone = &#39;13800138000&#39;</code></td>
</tr>
<tr>
<td><strong>隐式字符集转换</strong></td>
<td>关联字段字符集&#x2F;排序规则不同</td>
<td>统一 <code>CHARSET</code> 和 <code>COLLATE</code></td>
</tr>
<tr>
<td><strong>LIKE 以通配符开头</strong></td>
<td><code>WHERE name LIKE &#39;%Alice%&#39;</code></td>
<td>改用全文索引 &#x2F; 模糊搜索中间件（Elasticsearch）</td>
</tr>
<tr>
<td><strong>OR 条件未全覆盖索引</strong></td>
<td><code>WHERE a=1 OR b=2</code>（只有 a 有索引）</td>
<td>用 <code>UNION</code> 拆分，或给 b 也加索引</td>
</tr>
<tr>
<td><strong>不满足最左前缀</strong></td>
<td><code>WHERE b=2</code>（联合索引 <code>(a,b)</code>）</td>
<td>调整索引顺序或建单列索引</td>
</tr>
<tr>
<td><strong>数据区分度低</strong></td>
<td>对 <code>gender</code>（只有 男&#x2F;女）建索引</td>
<td>通常不建（除非配合其他列联合）</td>
</tr>
</tbody></table>
<hr>
<h2><span id="索引设计最佳实践总结清单">索引设计最佳实践（总结清单）</span></h2><ol>
<li><p><strong>主键首选自增 INT&#x2F;BIGINT</strong><br>→ 避免 UUID 乱序插入导致页分裂（如需分布式 ID，用雪花算法 + 前移时间位）。</p>
</li>
<li><p><strong>高频 WHERE &#x2F; JOIN &#x2F; ORDER BY 字段建索引</strong><br>→ 先用 <code>slow query log</code> 或 <code>EXPLAIN</code> 找慢查询。</p>
</li>
<li><p><strong>优先考虑联合索引</strong><br>→ 避免单列索引过多；按“等值在前，范围在后，排序最后”排序列。</p>
</li>
<li><p><strong>善用覆盖索引</strong><br>→ <code>SELECT</code> 的列尽量包含在索引中，减少回表。</p>
</li>
<li><p><strong>定期检查无效索引</strong>  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- MySQL 5.7+：查看未使用的索引（需开启 performance_schema）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.schema_unused_indexes;</span><br></pre></td></tr></table></figure>
<p>删除不用的索引，提升写性能。</p>
</li>
<li><p><strong>大表加索引用 <code>ALGORITHM=INPLACE</code>（Online DDL）</strong>  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> users </span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_name (name), </span><br><span class="line">ALGORITHM<span class="operator">=</span>INPLACE, LOCK<span class="operator">=</span><span class="keyword">NONE</span>;  <span class="comment">-- MySQL 5.6+ 支持，不锁表！</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>监控索引效率</strong>  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> users;  <span class="comment">-- 查看索引 Cardinality（区分度），越高越好</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h1><span id="事务">事务</span></h1><p>用于保证数据的一致性，要么全部成功，要么全部失败。</p>
<h2><span id="概念">概念</span></h2><h3><span id="场景用户-a-给用户-b-转账-100-元">场景：用户 A 给用户 B 转账 100 元</span></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 步骤1：A 扣款</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> <span class="keyword">user</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 步骤2：B 收款</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> <span class="keyword">user</span> <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p> <strong>问题</strong>：<br>如果步骤1成功，但步骤2因断电&#x2F;崩溃失败 → A 少了 100，B 没收到 → <strong>数据不一致！</strong></p>
<p>✅ <strong>事务的使命</strong>：把多个操作打包成一个“原子单元”，要么<strong>全成功</strong>，要么<strong>全失败回滚</strong>，绝不留半截状态！</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;  <span class="comment">-- 开启事务</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> <span class="keyword">user</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> <span class="keyword">user</span> <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;  <span class="comment">-- 全部成功 → 永久生效</span></span><br><span class="line"><span class="comment">-- 或 ROLLBACK; -- 任一失败 → 撤销所有修改</span></span><br></pre></td></tr></table></figure>

<p>设置保存点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SAVEPOINT A</span><br><span class="line">ROLLBACK A (不具体指向默认回退到初始点)</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="事务的四大特性acid">事务的四大特性：ACID</span></h2><table>
<thead>
<tr>
<th>字母</th>
<th>全称</th>
<th>含义</th>
<th>MySQL 如何保证</th>
</tr>
</thead>
<tbody><tr>
<td><strong>A</strong></td>
<td><strong>Atomicity（原子性）</strong></td>
<td>事务是最小单位，不可分割：要么全做，要么全不做</td>
<td>通过 <strong>Undo Log（回滚日志）</strong> 实现回滚</td>
</tr>
<tr>
<td><strong>C</strong></td>
<td><strong>Consistency（一致性）</strong></td>
<td>事务前后，数据库从一个<strong>合法状态</strong>转移到另一个<strong>合法状态</strong>（如约束、触发器、业务规则仍成立）</td>
<td>由 A + I + D 共同保障 + 应用逻辑</td>
</tr>
<tr>
<td><strong>I</strong></td>
<td><strong>Isolation（隔离性）</strong></td>
<td>多个事务并发执行时，<strong>互不干扰</strong>（如同串行执行）</td>
<td>通过 <strong>锁（Locking）</strong> + <strong>MVCC（多版本并发控制）</strong> 实现</td>
</tr>
<tr>
<td><strong>D</strong></td>
<td><strong>Durability（持久性）</strong></td>
<td>事务一旦提交，结果<strong>永久保存</strong>（即使宕机也不丢）</td>
<td>通过 <strong>Redo Log（重做日志）</strong> + <code>fsync</code> 写入磁盘</td>
</tr>
</tbody></table>
<blockquote>
<p> <strong>关键理解</strong>：</p>
<ul>
<li>ACID 不是 MySQL “发明”的，而是事务的<strong>设计目标</strong>；</li>
<li>InnoDB 引擎通过 <strong>WAL（Write-Ahead Logging）</strong> + <strong>Undo&#x2F;Redo Log</strong> 实现 ACID；</li>
<li>MyISAM <strong>不支持事务</strong>！务必用 <strong>InnoDB</strong>。</li>
</ul>
</blockquote>
<hr>
<h2><span id="事务隔离级别解决并发问题">事务隔离级别（解决并发问题）</span></h2><p>多个事务同时操作数据，可能引发 3 类经典问题：</p>
<table>
<thead>
<tr>
<th>问题</th>
<th>描述</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>脏读（Dirty Read）</strong></td>
<td>读到<strong>未提交</strong>的中间数据</td>
<td>T1 改余额为 900（未提交）→ T2 读到 900 → T1 回滚 → T2 依据错误数据决策</td>
</tr>
<tr>
<td><strong>不可重复读（Non-Repeatable Read）</strong></td>
<td>同一事务内，<strong>多次读同一行，结果不同</strong>（被别人改了）</td>
<td>T1 两次读 A 余额：第一次 1000 → T2 提交修改为 900 → T1 第二次读得 900</td>
</tr>
<tr>
<td><strong>幻读（Phantom Read）</strong></td>
<td>同一事务内，<strong>多次查同一范围，结果行数不同</strong>（被别人插入&#x2F;删除）</td>
<td>T1 <code>SELECT * FROM orders WHERE amount &gt; 100</code> 得 5 行 → T2 插入一条 150 的订单 → T1 再查得 6 行</td>
</tr>
</tbody></table>
<h3><span id="mysql-的-4-种隔离级别innodb-默认repeatable-read">MySQL 的 4 种隔离级别（InnoDB 默认：<strong>REPEATABLE READ</strong>）</span></h3><table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
<th>实现方式</th>
<th>性能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>READ UNCOMMITTED</strong></td>
<td>❌ 允许</td>
<td>❌ 允许</td>
<td>❌ 允许</td>
<td>几乎无锁</td>
<td>⚡ 最快</td>
</tr>
<tr>
<td><strong>READ COMMITTED</strong></td>
<td>✅ 禁止</td>
<td>❌ 允许</td>
<td>❌ 允许</td>
<td>行锁 + MVCC（每次读取最新已提交版本）</td>
<td>中</td>
</tr>
<tr>
<td><strong>REPEATABLE READ</strong>（MySQL 默认）</td>
<td>✅</td>
<td>✅</td>
<td>⚠️ <strong>InnoDB 用 MVCC + 间隙锁基本解决</strong></td>
<td>MVCC + <strong>Next-Key Lock（行锁+间隙锁）</strong></td>
<td>中</td>
</tr>
<tr>
<td><strong>SERIALIZABLE</strong></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>所有读加<strong>共享锁</strong>，串行执行</td>
<td>最慢</td>
</tr>
</tbody></table>
<blockquote>
<p>🔍 <strong>重点：InnoDB 的 RR 级别如何防止幻读？</strong></p>
<ul>
<li><strong>快照读（普通 SELECT）</strong>：通过 MVCC 读事务开始时的<strong>一致性视图</strong>，天然无幻读；</li>
<li><strong>当前读（SELECT … FOR UPDATE &#x2F; LOCK IN SHARE MODE &#x2F; UPDATE &#x2F; DELETE）</strong>：通过 <strong>Next-Key Lock</strong>（锁住记录 + 前后间隙）防止新记录插入。</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 当前读示例：防止别人在 (100, 200) 之间插新订单</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders </span><br><span class="line"><span class="keyword">WHERE</span> amount <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">AND</span> amount <span class="operator">&lt;</span> <span class="number">200</span> </span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;  <span class="comment">-- 加 Next-Key Lock</span></span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="事务控制语句实战语法">事务控制语句（实战语法）</span></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 开启事务（显式）</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 执行 SQL（DML：INSERT/UPDATE/DELETE）</span></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> <span class="keyword">user</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">INSERT INTO</span> transfers (from_user, to_user, amount) <span class="keyword">VALUES</span> (<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 提交 or 回滚</span></span><br><span class="line"><span class="keyword">COMMIT</span>;      <span class="comment">-- 永久生效</span></span><br><span class="line"><span class="comment">-- ROLLBACK; -- 撤销所有修改（到 START TRANSACTION 之前）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 设置保存点（部分回滚）</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span> sp1;</span><br><span class="line"><span class="keyword">UPDATE</span> ...;</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> sp1;  <span class="comment">-- 只回滚到 sp1，之前的操作仍保留</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> 注意：</p>
<ul>
<li>DDL（如 <code>CREATE TABLE</code>）、<code>LOCK TABLES</code> 会<strong>隐式提交</strong>当前事务；</li>
<li>客户端自动提交模式：  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@autocommit</span>;  <span class="comment">-- 1=开启（每条 SQL 自动 COMMIT），0=关闭</span></span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">-- 关闭自动提交，需手动 COMMIT</span></span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<hr>
<h2><span id="innodb-事务实现原理深入理解">InnoDB 事务实现原理（深入理解）</span></h2><h3><span id="核心组件">核心组件：</span></h3><table>
<thead>
<tr>
<th>组件</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Undo Log</strong></td>
<td>存储修改前的旧值 → 用于回滚（ROLLBACK）和 MVCC 快照读</td>
</tr>
<tr>
<td><strong>Redo Log</strong></td>
<td>存储修改后的物理日志 → 崩溃恢复时重做（保证 Durability）<br> <strong>Write-Ahead Logging：先写日志，再写数据页</strong></td>
</tr>
<tr>
<td><strong>Read View</strong></td>
<td>事务开启时生成的“一致性视图” → 决定能看到哪些版本的数据（MVCC 关键）</td>
</tr>
<tr>
<td><strong>Next-Key Lock</strong></td>
<td>行锁（Record Lock） + 间隙锁（Gap Lock） → 防止幻读</td>
</tr>
</tbody></table>
<h3><span id="事务执行流程简化">事务执行流程（简化）：</span></h3><ol>
<li><code>START TRANSACTION</code> → 生成 <strong>Read View</strong>；</li>
<li>执行 <code>UPDATE</code> →  <ul>
<li>修改 Buffer Pool 中的数据页；  </li>
<li>写 <strong>Undo Log</strong>（旧值）；  </li>
<li>写 <strong>Redo Log Buffer</strong>（新值）；</li>
</ul>
</li>
<li><code>COMMIT</code> →  <ul>
<li>Redo Log Buffer 刷盘（<code>fsync</code>）→ <strong>事务持久化</strong>；  </li>
<li>释放锁；</li>
</ul>
</li>
<li>后台线程异步刷脏页到磁盘。</li>
</ol>
<blockquote>
<p> <strong>崩溃恢复</strong>：重启时，InnoDB 用 Redo Log 重做已提交事务，用 Undo Log 回滚未提交事务。</p>
</blockquote>
<hr>
<h2><span id="事务使用最佳实践-amp-常见误区">事务使用最佳实践 &amp; 常见误区</span></h2><h3><span id="推荐做法">推荐做法：</span></h3><table>
<thead>
<tr>
<th>场景</th>
<th>建议</th>
</tr>
</thead>
<tbody><tr>
<td><strong>短事务</strong></td>
<td>尽量缩短事务时间（避免 <code>BEGIN</code> 后做耗时计算&#x2F;网络请求）→ 减少锁竞争</td>
</tr>
<tr>
<td><strong>小批量提交</strong></td>
<td>大量 INSERT&#x2F;UPDATE 分批提交（如每 1000 行 <code>COMMIT</code> 一次）→ 防止 Undo Log 暴胀</td>
</tr>
<tr>
<td><strong>明确隔离级别</strong></td>
<td>按需设置（如报表用 <code>READ COMMITTED</code>，金融用 <code>REPEATABLE READ</code>）：<br><code>SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</code></td>
</tr>
<tr>
<td><strong>异常处理</strong></td>
<td>代码中捕获异常 → 显式 <code>ROLLBACK</code>（避免连接池残留未提交事务）</td>
</tr>
<tr>
<td><strong>避免长事务</strong></td>
<td>监控 <code>information_schema.INNODB_TRX</code>，杀掉长时间未提交事务</td>
</tr>
</tbody></table>
<h3><span id="常见错误">常见错误：</span></h3><table>
<thead>
<tr>
<th>误区</th>
<th>后果</th>
<th>正确做法</th>
</tr>
</thead>
<tbody><tr>
<td><code>BEGIN</code> 后不 <code>COMMIT/ROLLBACK</code></td>
<td>连接一直占着锁 → 阻塞其他事务</td>
<td>用 <code>try-catch-finally</code> 确保提交&#x2F;回滚</td>
</tr>
<tr>
<td>在事务中调用外部 API</td>
<td>事务长时间挂起 → 锁超时、连接池耗尽</td>
<td>先提交事务 → 再调外部服务（用消息队列解耦）</td>
</tr>
<tr>
<td>默认隔离级别下误以为无幻读</td>
<td>当前读（<code>FOR UPDATE</code>）仍可能见幻读</td>
<td>理解 MVCC vs 当前读区别；必要时显式加锁</td>
</tr>
<tr>
<td>大事务导致主从延迟</td>
<td>Redo Log 太多，从库追不上</td>
<td>分批提交 + 并行复制</td>
</tr>
</tbody></table>
<hr>
<h2><span id="如何监控事务">如何监控事务？</span></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 查看当前运行的事务（重点关注 trx_state, trx_started）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.INNODB_TRX;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 查看锁等待</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sys.innodb_lock_waits;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 查看长事务（运行超过 60 秒）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.INNODB_TRX </span><br><span class="line"><span class="keyword">WHERE</span> TIME_TO_SEC(TIMEDIFF(NOW(), trx_started)) <span class="operator">&gt;</span> <span class="number">60</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h1><span id="存储引擎">存储引擎</span></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SHOW ENGINES</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW ENGINES;</span><br><span class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class="line">| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |</span><br><span class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class="line">| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |</span><br><span class="line">| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |</span><br><span class="line">| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables     | NO           | NO   | NO         |</span><br><span class="line">| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears)| NO           | NO   | NO         |</span><br><span class="line">| MyISAM             | YES     | Non-transactional engine with good read performance            | NO           | NO   | NO         |</span><br><span class="line">| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |</span><br><span class="line">| ARCHIVE            | YES     | Compression-focused storage engine for archival data           | NO           | NO   | NO         |</span><br><span class="line">| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |</span><br><span class="line">| FEDERATED          | NO      | Federated MySQL storage engine (not available in 8.0+)        | NULL         | NULL | NULL       |</span><br><span class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br></pre></td></tr></table></figure>
<ul>
<li>Support：DEFAULT &#x3D; 默认引擎；YES &#x3D; 支持但非默认；NO &#x3D; 编译支持但禁用；DISABLED &#x3D; 不支持</li>
<li>Transactions：是否支持事务（YES &#x3D; 事务安全型；NO &#x3D; 非事务安全型）</li>
<li>XA：是否支持分布式事务（XA 协议）</li>
<li>Savepoints：是否支持保存点（SAVEPOINT &#x2F; ROLLBACK TO）</li>
</ul>
<h2><span id="事务安全型">事务安全型</span></h2><h3><span id="innodbmysql-55-默认引擎">InnoDB（MySQL 5.5+ 默认引擎）</span></h3><table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>✅ <strong>事务支持</strong></td>
<td>ACID 全满足（靠 Undo Log + Redo Log + MVCC）</td>
</tr>
<tr>
<td>✅ <strong>行级锁</strong></td>
<td>并发写入性能高（MyISAM 是表锁）</td>
</tr>
<tr>
<td>✅ <strong>外键约束</strong></td>
<td><code>FOREIGN KEY</code> 支持（数据完整性保障）</td>
</tr>
<tr>
<td>✅ <strong>崩溃恢复</strong></td>
<td>重启自动恢复，数据不丢失</td>
</tr>
<tr>
<td>✅ <strong>MVCC</strong></td>
<td>多版本并发控制，高并发读写无阻塞</td>
</tr>
<tr>
<td>✅ <strong>全文索引</strong></td>
<td>MySQL 5.6+ 支持（<code>FULLTEXT</code>）</td>
</tr>
<tr>
<td>✅ <strong>数据压缩</strong></td>
<td>支持页压缩（节省磁盘）</td>
</tr>
</tbody></table>
<hr>
<h2><span id="非事务安全型">非事务安全型</span></h2><table>
<thead>
<tr>
<th>引擎</th>
<th>特点</th>
<th>适用场景</th>
<th>⚠️ 主要缺陷</th>
</tr>
</thead>
<tbody><tr>
<td><strong>MyISAM</strong></td>
<td>• 表级锁（写阻塞读）<br>• 查询快（尤其 COUNT(*)）<br>• 支持全文索引（旧版）<br>• 不支持事务&#x2F;外键</td>
<td>• 只读报表库<br>• 日志归档（极少更新）<br>• 低频读、无并发写场景</td>
<td>• 崩溃后需手动修复（<code>myisamchk</code>）<br>• 写入时全表锁 → 高并发下性能差<br>• 无崩溃恢复 → 可能丢数据</td>
</tr>
<tr>
<td><strong>MEMORY</strong></td>
<td>• 数据全在内存<br>• 哈希&#x2F; B树索引<br>• 极快读写</td>
<td>• 临时缓存表<br>• 会话级临时数据<br>• 小型维度表</td>
<td>• 重启数据全丢<br>• 不支持 BLOB&#x2F;TEXT<br>• 内存有限，易 OOM</td>
</tr>
<tr>
<td><strong>CSV</strong></td>
<td>• 数据存为 CSV 文件<br>• 可直接用文本工具编辑</td>
<td>• 数据导入导出中转<br>• 与外部系统交换数据</td>
<td>• 无索引<br>• 不支持 NULL<br>• 全表扫描</td>
</tr>
<tr>
<td><strong>ARCHIVE</strong></td>
<td>• 高压缩比（zlib）<br>• 只支持 INSERT &#x2F; SELECT</td>
<td>• 日志、审计、历史归档（只追加不更新）</td>
<td>• 无索引（全表扫描）<br>• 不支持 DELETE&#x2F;UPDATE</td>
</tr>
<tr>
<td><strong>BLACKHOLE</strong></td>
<td>• 写入即丢弃（<code>/dev/null</code>）</td>
<td>• 主从复制中“过滤”数据<br>• 压测写入吞吐</td>
<td>• 数据不持久化</td>
</tr>
</tbody></table>
<hr>
<hr>
<h2><span id="如何查看x2f设置表的存储引擎">如何查看&#x2F;设置表的存储引擎？</span></h2><h3><span id="1-查看某张表的引擎">1. 查看某张表的引擎：</span></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE TABLE</span> users;  <span class="comment">-- 看 CREATE 语句末尾的 ENGINE=...</span></span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">SELECT</span> ENGINE <span class="keyword">FROM</span> information_schema.TABLES </span><br><span class="line"><span class="keyword">WHERE</span> TABLE_SCHEMA <span class="operator">=</span> <span class="string">&#x27;your_db&#x27;</span> <span class="keyword">AND</span> TABLE_NAME <span class="operator">=</span> <span class="string">&#x27;users&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3><span id="2-建表时指定引擎">2. 建表时指定引擎：</span></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> orders (</span><br><span class="line">    id <span class="type">BIGINT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    amount <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB;  <span class="comment">-- 显式指定（推荐）</span></span><br></pre></td></tr></table></figure>

<h3><span id="3-修改已有表的引擎谨慎大数据量会锁表">3. 修改已有表的引擎（谨慎！大数据量会锁表）：</span></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> old_myisam_table ENGINE <span class="operator">=</span> InnoDB;</span><br><span class="line"><span class="comment">-- ⚠️ 大表建议用 pt-online-schema-change 工具在线转换</span></span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="选择存储引擎决策树">选择存储引擎决策树</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[需要事务/外键/崩溃恢复？] </span><br><span class="line">    --&gt;|是| B[选 InnoDB]</span><br><span class="line">    A --&gt;|否| C&#123;主要是读？写很少？&#125;</span><br><span class="line">    C --&gt;|是| D&#123;需要极快 COUNT* 或全文检索（旧版）？&#125;</span><br><span class="line">    D --&gt;|是| E[考虑 MyISAM]</span><br><span class="line">    D --&gt;|否| F&#123;数据临时/内存足够？&#125;</span><br><span class="line">    F --&gt;|是| G[MEMORY]</span><br><span class="line">    F --&gt;|否| H&#123;只追加不更新？需高压缩？&#125;</span><br><span class="line">    H --&gt;|是| I[ARCHIVE]</span><br><span class="line">    H --&gt;|否| J[仍推荐 InnoDB]</span><br><span class="line">    C --&gt;|否（高并发写）| B</span><br></pre></td></tr></table></figure>

<blockquote>
<p> <strong>终极建议</strong>：<br><strong>除非有非常明确的特殊需求（如 MEMORY 做缓存），否则一律用 <code>InnoDB</code>！</strong><br>它是 MySQL 社区和官方持续优化的重点，功能、稳定性、性能综合最佳。</p>
</blockquote>
<hr>
<h2><span id="附innodb-vs-myisam-关键对比表">附：InnoDB vs MyISAM 关键对比表</span></h2><table>
<thead>
<tr>
<th>特性</th>
<th>InnoDB</th>
<th>MyISAM</th>
</tr>
</thead>
<tbody><tr>
<td><strong>事务</strong></td>
<td>✅ ACID</td>
<td>❌</td>
</tr>
<tr>
<td><strong>锁粒度</strong></td>
<td>行锁</td>
<td>表锁</td>
</tr>
<tr>
<td><strong>外键</strong></td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td><strong>崩溃恢复</strong></td>
<td>✅ 自动</td>
<td>❌ 需手动修复</td>
</tr>
<tr>
<td><strong>全文索引</strong></td>
<td>✅（5.6+）</td>
<td>✅（但旧版）</td>
</tr>
<tr>
<td><strong>COUNT(*)</strong></td>
<td>慢（需扫描）</td>
<td>快（存了行数）</td>
</tr>
<tr>
<td><strong>存储空间</strong></td>
<td>稍大（存双写缓冲等）</td>
<td>小</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>通用、高可靠</td>
<td>只读&#x2F;低写</td>
</tr>
</tbody></table>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/19/Java%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DarkYellowCat">
      <meta itemprop="description" content="记录学习与成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarkYellowCat's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/19/Java%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">Java Web框架</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-19 15:28:11" itemprop="dateCreated datePublished" datetime="2025-11-19T15:28:11+00:00">2025-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-01-25 01:59:12" itemprop="dateModified" datetime="2026-01-25T01:59:12+00:00">2026-01-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1><span id="前言">前言</span></h1><p>在学习Spring Boot时了解到这是一个整合Web&#x2F;持久层(持久层框架（如MyBatis&#x2F;Hibernate）属于数据访问层组件，与Web框架是协作关系而非包含关系。)的全栈框架，但对于各种框架的含义仍缺乏了解，故在此系统梳理一下。</p>
<h1><span id="框架">框架</span></h1><h2><span id="定义">定义</span></h2><p>Java Web框架是封装好的专为构建Web应用的代码骨架，为开发者提供标准化的开发基础。在框架中预先写好了许多基础或底层功能，让开发者可以在开发时避免在这些琐碎的方面浪费时间，专心于业务逻辑和核心代码构建。</p>
<h2><span id="核心功能">核心功能</span></h2><p>1.提升开发效率。 框架可以通过调用接口等方式自动化处理如数据库操作、HTTP请求解析等重复性任务。</p>
<p>2.生态整合。 一些框架会集成数据库、缓存、消息队列等第三方组件，不需要开发者进行二次引入(SpringBoot自带Tomcat)。</p>
<p>3.提高维护性。 模块化设计降低代码耦合度，便于后期扩展。</p>
<h1><span id="分类">分类</span></h1><h2><span id="架构风格分类">架构风格分类</span></h2><h3><span id="1-传统-mvc-框架">1. 传统 MVC 框架</span></h3><ul>
<li><strong>代表框架：</strong> Spring MVC, Struts2 (已过时)</li>
<li><strong>特点：</strong> 基于 Servlet 规范，采用同步阻塞 I&#x2F;O 模型。严格遵循 Model-View-Controller 分层设计，强调职责分离。通常配合 JSP、Thymeleaf 等模板引擎进行服务端渲染 (SSR)。</li>
<li><strong>适用于：</strong> 传统的企业级单体应用、后台管理系统、SEO 友好的门户网站。</li>
</ul>
<h3><span id="2-微框架-micro-frameworks">2. 微框架 (Micro-frameworks)</span></h3><ul>
<li><strong>代表框架：</strong> Javalin, Spark Java, Blade</li>
<li><strong>特点：</strong> 极简设计 (核心库往往 &lt;1MB)，不强制特定的项目结构。去除了复杂的依赖注入和繁重的配置，专注于提供轻量级的 HTTP 路由和 API 处理。</li>
<li><strong>适用于：</strong> 轻量级微服务、简单的 RESTful API、原型快速开发、教学演示。</li>
</ul>
<h3><span id="3-云原生框架-cloud-native">3. 云原生框架 (Cloud-Native)</span></h3><ul>
<li><strong>代表框架：</strong> Quarkus, Micronaut, Helidon</li>
<li><strong>特点：</strong> “为云而生”。通过编译时依赖注入 (Compile-time DI) 和 AOT (Ahead-of-Time) 预编译技术，显著减少内存占用和启动时间。完美适配 Kubernetes 环境，且对 GraalVM 原生镜像有极佳支持。</li>
<li><strong>适用于：</strong> Serverless (无服务器架构)、高密度部署的容器化微服务、对启动速度和内存有严格要求的场景 (如 AWS Lambda)。</li>
</ul>
<h3><span id="4-响应式框架-reactive">4. 响应式框架 (Reactive)</span></h3><ul>
<li><strong>代表框架：</strong> Spring WebFlux, Vert.x</li>
<li><strong>特点：</strong> 基于 Netty 等非阻塞服务器，采用异步非阻塞 I&#x2F;O 模型和事件驱动架构。能够以少量的线程处理极高的并发请求，背压 (Backpressure) 机制保证系统稳定性。</li>
<li><strong>适用于：</strong> 高并发系统 (如网关、社交 IM)、I&#x2F;O 密集型应用、实时数据流处理。</li>
</ul>
<h2><span id="按部署形态分类">按部署形态分类</span></h2><h3><span id="1-嵌入式服务器框架">1. 嵌入式服务器框架</span></h3><ul>
<li><strong>代表：</strong> Spring Boot</li>
<li><strong>形态：</strong> 内嵌 Tomcat&#x2F;Jetty&#x2F;Undertow(4里取消支持Undertow了，不知道未来会不会支持，先插个眼) 容器。</li>
<li><strong>特点：</strong> 打包为可执行的 Fat JAR，<code>java -jar</code> 即可运行，不再依赖外部 Web 容器。</li>
<li><strong>性能：</strong> 启动时间通常在 1-5 秒，开发体验极佳。</li>
</ul>
<h3><span id="2-graalvm-原生框架">2. GraalVM 原生框架</span></h3><ul>
<li><strong>代表：</strong> Quarkus Native, Micronaut Native</li>
<li><strong>形态：</strong> 经 GraalVM 编译为本地机器码 (Binary)。</li>
<li><strong>特点：</strong> 启动速度极快 (&lt;50ms)，内存占用极低 (&lt;30MB)，但构建 (Build) 时间较长，且反射机制受限。</li>
<li><strong>性能：</strong> “冷启动”几乎消失，非常适合 Serverless。</li>
</ul>
<h3><span id="3-传统-war-部署框架">3. 传统 WAR 部署框架</span></h3><ul>
<li><strong>代表：</strong> JSF + WebLogic&#x2F;JBoss</li>
<li><strong>形态：</strong> 打包为 WAR 文件，需部署到独立的外部应用服务器中。</li>
<li><strong>特点：</strong> 配置繁琐，依赖服务器环境，且应用服务器本身启动沉重。</li>
<li><strong>现状：</strong> 主要存在于遗留系统 (Legacy Systems) 中，新项目已很少采用。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/14/SpringSecurity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DarkYellowCat">
      <meta itemprop="description" content="记录学习与成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarkYellowCat's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/14/SpringSecurity/" class="post-title-link" itemprop="url">SpringSecurity配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-14 12:00:00" itemprop="dateCreated datePublished" datetime="2025-11-14T12:00:00+00:00">2025-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-01-25 01:59:12" itemprop="dateModified" datetime="2026-01-25T01:59:12+00:00">2026-01-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1><span id="引入">引入</span></h1><p>之前跟着教程做了web后端的项目，打算找个时间上线运营培养经验，不过因为域名的问题一直拖着没做。</p>
<p>但在学习网络安全时，老师提了一句：“为什么不用MD5加密，因为它已经被破解了”，一句话让我的困意瞬间消失。因为我的加密就是用MD5。</p>
<h1><span id="md5为什么不能用">MD5为什么不能用</span></h1><h2><span id="md5的加密逻辑">MD5的加密逻辑</span></h2><p>将输入数据扩展为 512 位的整数倍，用四个 32 位的十六进制整数作为初始链接变量进行四轮循环运算，每轮循环包含 16 次操作，共 64 步。每轮循环结束后，将当前链接变量 A、B、C、D 分别加上临时变量 a、b、c、d。最终，将四个链接变量级联，得到 128 位的 MD5 哈希值。</p>
<h2><span id="缺点">缺点</span></h2><h3><span id="1计算太快">1.计算太快</span></h3><p>对于选择的电脑的性能，MD5的计算量太少，攻击者可以轻松通过计算进行解密。</p>
<h3><span id="2被证明过不安全">2.被证明过不安全</span></h3><p>王小云研究团队发现了MD5国际密码算法存在漏洞，被证实MD5并不安全。</p>
<h1><span id="选择springsecurity的原因">选择SpringSecurity的原因</span></h1><h2><span id="优势">优势</span></h2><h3><span id="1导入便捷">1.导入便捷</span></h3><p>SpringSecurity 对于 SpringBoot 项目来说几乎是“标配安全框架”，只需要在pom.xml文件中加入配置就可以进行使用。</p>
<h3><span id="2自带bcrypt加密安全">2.自带BCrypt，加密安全</span></h3><p>BCrypt是慢哈希函数，适合存储密码，带 salt，不可逆，抗暴力破解。</p>
<h3><span id="3内置认证-授权体系">3.内置认证 + 授权体系</span></h3><p>Security会自己处理：登录验证、过滤器链、会话安全、跨域、csrf、路由权限控制等问题，开发者不需要操心这些方面的问题。</p>
<h1><span id="配置和导入">配置和导入</span></h1><h2><span id="1依赖">1.依赖</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h2><span id="2-配置类">2. 配置类</span></h2><h3><span id="补充之前没注意spring2和spring3的区别">补充：之前没注意Spring2和Spring3的区别</span></h3><p>Spring Boot 2.x 配置方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSecurity</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">                .antMatchers(&quot;/public/**&quot;).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作者：刘大华<br>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7570191839593332799">https://juejin.cn/post/7570191839593332799</a></p>
<p>来源：稀土掘金</p>
<p>SpringBoot 3 去掉了 WebSecurityConfigurerAdapter，用 Bean 配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSecurity</span><br><span class="line">public class SecurityConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public PasswordEncoder passwordEncoder() &#123;</span><br><span class="line">        return new BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            .csrf(csrf -&gt; csrf.disable())</span><br><span class="line">            .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">                .requestMatchers(&quot;/login&quot;, &quot;/register&quot;).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">            )</span><br><span class="line">            .formLogin(login -&gt; login</span><br><span class="line">                .loginPage(&quot;/login&quot;)</span><br><span class="line">                .permitAll()</span><br><span class="line">            );</span><br><span class="line">        return http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="如何兼容之前的用户">如何兼容之前的用户</span></h2><p>之前在数据库中存储的密码是MD5加密的，如果直接更新加密方法，会导致之前的用户无法登录。所以需要增加一段逻辑。</p>
<p>用户注册-&gt;直接使用SpringSecurity加密。</p>
<p>用户登录-&gt;如果使用MD5加密：用MD5验证-&gt;更新加密逻辑，将新的数据存入数据库。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/13/%E6%B2%99%E7%AE%B1Sandbox/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="DarkYellowCat">
      <meta itemprop="description" content="记录学习与成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DarkYellowCat's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/13/%E6%B2%99%E7%AE%B1Sandbox/" class="post-title-link" itemprop="url">沙箱初步认识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-13 12:00:00" itemprop="dateCreated datePublished" datetime="2025-11-13T12:00:00+00:00">2025-11-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2026-01-25 01:59:12" itemprop="dateModified" datetime="2026-01-25T01:59:12+00:00">2026-01-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1><span id="为什么要学沙箱">为什么要学沙箱</span></h1><p>第一次接触这个概念是因为Python的期末大作业，老师让我们写一个python学习的平台。</p>
<p>我想到模仿<a target="_blank" rel="noopener" href="https://www.freecodecamp.org/">FreeCodecamp</a>，写一个可以通过程序二次运行python代码的平台。</p>
<p>之前也没有相关的经验，我便将自己的想法发给ai，让它告诉我需要用到什么，也就接触到了沙箱–用于防止别人在执行代码时对程序(或电脑)造成破坏。</p>
<h1><span id="概念">概念</span></h1><p>沙箱（Sandboxing）是一种用于隔离环境的技术。</p>
<h1><span id="用途">用途</span></h1><p>沙箱技术通常用于以下几类场景：</p>
<ul>
<li><strong>在线代码运行平台</strong>：如 LeetCode、FreeCodeCamp、自建 OJ 系统</li>
<li><strong>浏览器隔离</strong>：Chrome 的每个 tab 页就是一个沙箱进程</li>
<li><strong>移动端应用权限管理</strong>：iOS、Android 对 App 的文件访问就是沙箱设计</li>
<li><strong>恶意软件分析</strong>：将样本放在沙箱中运行，观察行为</li>
<li><strong>插件系统</strong>：比如浏览器扩展、VSCode 插件，都不能直接访问用户系统</li>
<li><strong>安全研究和渗透测试</strong>有专门做沙箱业务的公司</li>
</ul>
<p>这些场景的共同点就是：“<strong>运行不可信代码</strong>”，而沙箱的职责就是“<strong>让它尽量跑得动，但伤不到我</strong>”。</p>
<h1><span id="分类">分类</span></h1><p>根据隔离程度不同，可以粗略分成三类：</p>
<h3><span id="1-语言级沙箱最轻量">1. 语言级沙箱（最轻量）</span></h3><p>依赖语言本身的机制进行限制。</p>
<ul>
<li>Python 的 <code>ast</code>、受控 namespace</li>
<li>JavaScript 的 <code>vm2</code></li>
<li>Lua 沙箱化 runtime</li>
</ul>
<p>优点：实现简单，启动快<br>缺点：很容易被绕过，安全性弱</p>
<h3><span id="2-系统级沙箱中等级别">2. 系统级沙箱（中等级别）</span></h3><p>依赖操作系统提供的隔离机制：</p>
<ul>
<li>Linux cgroups（限制资源）</li>
<li>namespace（隔离进程、文件系统、网络）</li>
<li>seccomp（限制系统调用）</li>
<li>Docker &#x2F; LXC（容器）</li>
</ul>
<p>优点：安全性高、性能好<br>缺点：实现较复杂，需要系统层面的支持</p>
<h3><span id="3-虚拟化级沙箱最高隔离">3. 虚拟化级沙箱（最高隔离）</span></h3><p>原来我用过这么久沙箱…</p>
<ul>
<li>KVM</li>
<li>QEMU</li>
<li>Firecracker（AWS Lambda 用的）</li>
<li>VirtualBox</li>
</ul>
<p>优点：隔离性能好<br>缺点：启动慢、消耗资源大，不适合大量高频的代码执行</p>
<h1><span id="实现模板">实现模板</span></h1><h2><span id="java">Java</span></h2><p>java.lang.SecurityManager是Java的一个可插拔的安全策略执行器，用于在运行时对敏感操作（如文件读写、网络访问、反射调用、类加载等）进行权限检查。</p>
<p>当某段代码执行特权操作时，JVM 会调用 SecurityManager.checkXXX() 方法（如 checkRead, checkConnect, checkPermission 等），若未授权，则抛出 SecurityException。</p>
<p>虽然“安全管理员多年来一直不是保护客户端 Java 代码的主要手段，也很少用于保护服务器端代码，并且维护成本很高。”（官方回复），导致这个类在JDK17后被淘汰了，但作为新手去学习依旧足够了。</p>
<h2><span id="python">Python</span></h2><p>目前还在写(前文提到的)，先插个眼 </p>
<p>TODO</p>
<h1><span id="一些开源的沙盒项目">一些开源的沙盒项目</span></h1><p><a target="_blank" rel="noopener" href="https://github.com/sandboxie-plus/Sandboxie">https://github.com/sandboxie-plus/Sandboxie</a> Sandboxie 允许您创建几乎无限的沙箱并单独或同时运行它们，以将程序与主机隔离并相互隔离，同时还允许您在单个盒子中同时运行任意数量的程序。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/alibaba/jvm-sandbox">https://github.com/alibaba/jvm-sandbox</a><br>JVM-SANDBOX（沙箱）实现了一种在不重启、不侵入目标JVM应用的AOP解决方案。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">DarkYellowCat</p>
  <div class="site-description" itemprop="description">记录学习与成长</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DarkYellowCat</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

<script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script>
<script>LA.init({id:"3OnjqyPOaoYCHllV",ck:"3OnjqyPOaoYCHllV"})</script>
        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
